<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <title>多功能桌面小工具</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            overflow: hidden;
            height: 100%;
            width: 100%;
        }
        body {
            font-family: 'Noto Sans TC', 'Inter', sans-serif;
            font-weight: bold;
            background-color: var(--bg-primary, #000000);
            color: var(--text-primary, #F3F4F6);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* --- 通用 Widget 容器樣式 --- */
        .widget-container {
            position: absolute;
            box-sizing: border-box; user-select: none;
            display: flex; flex-direction: column;
            background-color: transparent; z-index: 10;
            padding: 0;
            transform-origin: center center;
        }
        .widget-container.edit-mode:not(:has(.control-handle:hover)) { cursor: move; }
        
        /* --- CSS 編輯模式邊框 --- */
        .widget-container.edit-mode::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px dashed rgba(0, 255, 255, 0.5);
            pointer-events: none;
            transition: border-color 0.3s;
            box-sizing: border-box;
            border-radius: inherit; /* 繼承容器的圓角設定 */
        }

        .widget-container.selected-for-group::after {
            border-color: rgba(255, 255, 0, 0.8) !important;
        }

        .widget-content-wrapper {
            width: 100%; height: 100%; flex-grow: 1;
            display: flex; flex-direction: column;
            min-height: 0; position: relative;
        }
        .widget-content-wrapper > main {
            flex-grow: 1; display: flex; flex-direction: column;
            min-height: 0;
        }
        /* --- 月曆共用樣式 (Refactored) --- */
        .calendar-widget main { overflow: hidden; }
        .calendar-widget .calendar-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 0; margin: 0; position: relative; z-index: 2;
        }
        .calendar-widget .calendar-title {
            font-weight: 700; letter-spacing: 0.025em; padding: 0; margin: 0;
            cursor: pointer; color: var(--year-color);
            transition: color 150ms cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap; display: flex; align-items: center;
            gap: 4px; height: 30px;
        }
        .calendar-widget .calendar-title:hover { color: #a5b4fc; }
        .calendar-widget .calendar-nav {
            display: flex; align-items: center; padding: 0; margin: 0; flex-shrink: 0;
        }
        .calendar-widget .calendar-nav-arrow,
        .calendar-widget .calendar-nav-today {
            display: inline-flex; align-items: center; justify-content: center;
            height: 1.5rem; padding: 0 0.25rem; margin: 0;
            transition: color 150ms cubic-bezier(0.4, 0, 0.2, 1), background-color 150ms cubic-bezier(0.4, 0, 0.2, 1);
        }
        .calendar-widget .calendar-nav-today { font-weight: 700; }
        .calendar-widget .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 0; }
        .calendar-widget .calendar-day {
            padding: 0.25rem; margin: 0; display: flex; flex-direction: column; justify-content: flex-start;
            align-items: center; font-size: 0.9em; border: 1px solid #555; cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s; background-color: transparent;
            z-index: 1; position: relative; overflow: hidden;
        }
        .calendar-widget .calendar-day:not(.edit-mode-active):hover { background-color: var(--bg-hover); cursor: pointer; }
        .calendar-widget .day-header {
            border: 1px solid #555; background-color: var(--bg-secondary); color: var(--week-color);
            font-size: 1.2em; padding: 0; text-align: center; font-weight: 600;
        }
        .calendar-widget .today { background-color: #ff000080; color: white; box-shadow: 0 0 10px 1px #FF0000; border-radius: 0.5em; }
        .calendar-widget .other-month { color: var(--text-muted); opacity: 0.4; }
        .calendar-widget .background-month {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-weight: 900; color: var(--month-color); z-index: 1; user-select: none;
            opacity: 0.6; line-height: 0.6; pointer-events: none;
        }
        #calendar-body, #moon-calendar-body { flex-grow: 1; display: grid; min-height: 0; }
        /* --- 標準月曆 spezifische樣式 --- */
        .calendar-day.with-moon-icon { flex-direction: row; justify-content: space-between; align-items: flex-start; }
        .day-text-content { display: flex; flex-direction: column; align-items: flex-start; flex-grow: 1; min-width: 0; }
        .day-moon-container { flex-shrink: 0; margin-left: 0.25rem; }
        .day-number-wrapper { margin-bottom: 2px; }
        .lunar-date { font-size: 1.2em; color: var(--lunar-color); line-height: 1; }
        .holiday-text, .solarterm-text { font-size: 1.2em; font-weight: 500; cursor: help; line-height: 1; }
        .holiday-text { color: var(--holiday-color); }
        .solarterm-text { color: var(--solarterm-color); }
        .truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .space-y-px > :not([hidden]) ~ :not([hidden]) { margin-top: 1px; }
        .today .lunar-date, .today .holiday-text, .today .solarterm-text { color: #C7D2FE; }
        /* --- 月相曆 spezifische樣式 --- */
        #moon-phase-container .calendar-day.selected { border-color: var(--moon-highlight-color); box-shadow: 0 0 5px var(--moon-highlight-color); border-radius: 0.375rem; }
        .moon-icon-small svg { width: 100%; height: auto; max-width: 28px; margin: 0 auto; }
        /* --- Modal 內部元素樣式 --- */
        .led-text-unit { font-family: 'Noto Sans TC', 'Inter', sans-serif; font-weight: bold; display: inline-block; vertical-align: baseline; padding: 0 4px; line-height: 1; font-size: 22px; color: white; }
        #modal-gregorian-date { display: flex; align-items: flex-end; justify-content: center; flex-wrap: wrap; gap: 2px; }
        #modal-lunar-date { display: flex; align-items: center; justify-content: center; gap: 4px; }
        .countdown-text-container { display: flex; align-items: center; justify-content: center; gap: 4px; }
        .countdown-text-container svg { vertical-align: middle; }
        #moon-detail-icon svg { width: 120px; height: 120px; }
        /* --- LED 時鐘 spezifische樣式 --- */
        #led-clock-container svg { width: 100%; height: 100%; overflow: visible; }
        #led-clock-container .segment { transition: opacity 0.2s ease-in-out; }
        #led-clock-container .segment-h { fill: var(--led-hour-color); }
        #led-clock-container .segment-m { fill: var(--led-minute-color); }
        #led-clock-container .segment-s { fill: var(--led-second-color); }
        #led-clock-container .colon { fill: var(--led-colon-color); }
        #led-clock-container .period-text { fill: var(--led-period-color); font-size: 50px; }
        .period-text { position: absolute; top: 0; right: -10vw; }
        /* --- 指針時鐘 spezifische樣式 --- */
        #analog-clock-container { border-radius: 50%; }
        #analog-clock-container .resize-handle-w, #analog-clock-container .resize-handle-h { display: none !important; }
        #analog-clock-container main { aspect-ratio: 1 / 1; border-radius: 50%; background-color: var(--analog-face-color); clip-path: circle(50%); overflow: hidden;}
        .analog-clock-face { position: relative; width: 100%; height: 100%; }
        .analog-hand { position: absolute; bottom: 50%; left: 50%; transform-origin: bottom; background-color: var(--analog-hand-color); border-radius: 50% 50% 0 0; }
        .hour-hand { width: 1.5%; height: 25%; z-index: 5; }
        .minute-hand { width: 1%; height: 40%; z-index: 6; }
        .second-hand { width: 0.5%; height: 45%; background-color: var(--analog-second-hand-color); z-index: 7; }
        .analog-pivot { position: absolute; top: 50%; left: 50%; width: 3%; height: 3%; background-color: var(--analog-second-hand-color); border-radius: 50%; transform: translate(-50%, -50%); z-index: 8; }
        .ticks-container { width: 100%; height: 100%; z-index: 2; }
        .tick-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .tick { position: absolute; background-color: var(--analog-tick-color); }
        .tick-minute { top: 1%; left: 49.75%; width: 0.5%; height: 2%; border-radius: 1px; }
        .tick-hour { top: 1%; left: 49.5%; width: 1%; height: 4%; border-radius: 1px; }
        .number { position: absolute; top: 6%; left: 0; width: 100%; height: 10%; display: flex; align-items: center; justify-content: center; }
        .number > div { transform: rotate(calc(-1 * var(--rotation))); display: flex; align-items: center; justify-content: center; }
        /* --- 跑馬燈 spezifische樣式 --- */
        .marquee-widget main { display: flex; align-items: center; justify-content: flex-start; width: 100%; height: 100%; overflow: hidden; transform: translateZ(0); -webkit-transform: translateZ(0); }
        .marquee-inner { display: flex; width: fit-content; height: fit-content; will-change: transform; transform: translateZ(0); font-variant-numeric: tabular-nums; font-feature-settings: 'tnum'; -webkit-backface-visibility: hidden; backface-visibility: hidden; perspective: 1000px; margin-right: auto; }
        .marquee-text-instance { white-space: nowrap; flex-shrink: 0; line-height: 1; display: inline-flex; align-items: center; }
        .marquee-text-instance > span { vertical-align: middle; }
        .marquee-text-instance svg { vertical-align: middle; }
        /* --- 控制點樣式 --- */
        .control-handle { position: absolute; background-color: rgba(79, 70, 229, 0.8); border-radius: 50%; display: none; z-index: 100; }
        .widget-container.edit-mode .control-handle { display: block; }
        .move-handle { display: none !important; } /* 拿掉移動圖示 */
        .reset-handle {
            position: absolute; width: 24px; height: 24px; top: -12px; right: -12px; cursor: pointer;
            padding: 2px; border-radius: 50%; background-color: rgba(239, 68, 68, 0.8); z-index: 101;
            transform-origin: center; align-items: center; justify-content: center;
        }
        .widget-container.edit-mode .reset-handle { display: flex; }
        .resize-handle-w { width: 8px; height: 50px; top: 50%; right: -4px; transform: translateY(-50%); border-radius: 4px; cursor: ew-resize; }
        .resize-handle-h { width: 50px; height: 8px; bottom: -4px; left: 50%; transform: translateX(-50%); border-radius: 4px; cursor: ns-resize; }
        .rotate-handle {
            width: 24px; height: 24px; position: absolute; bottom: -12px; right: -12px;
            cursor: alias; padding: 4px; transform-origin: center; display: none;
        }
        .scale-handle { /* 新增縮放圖示 */
            width: 24px; height: 24px; position: absolute; bottom: -12px; left: -12px;
            cursor: se-resize; padding: 4px; transform-origin: center; display: none;
        }
        .widget-container.edit-mode .rotate-handle, .widget-container.edit-mode .scale-handle { display: flex; align-items: center; justify-content: center; }
        .group-select-handle { 
            position: absolute; top: -12px; left: -12px; width: 24px; height: 24px; cursor: pointer; 
            z-index: 101; display: none; background-color: rgba(0, 255, 255, 0.5); 
            border-radius: 50%; padding: 2px; transform-origin: center; 
        }
        .widget-container.edit-mode .group-select-handle { display: block; }
        .widget-container.selected-for-group { box-shadow: 0 0 10px rgba(255, 255, 0, 0.5); }
        #group-move-handle { position: absolute; width: 32px; height: 32px; z-index: 200; cursor: move; background-color: rgba(255, 255, 0, 0.8); border-radius: 6px; padding: 4px; display: flex; align-items: center; justify-content: center; }
        #group-rotate-handle { position: absolute; width: 28px; height: 28px; z-index: 200; cursor: alias; background-color: rgba(255, 255, 0, 0.8); border-radius: 50%; padding: 4px; display: flex; align-items: center; justify-content: center; }
        #group-scale-handle { position: absolute; width: 28px; height: 28px; z-index: 200; cursor: se-resize; background-color: rgba(255, 255, 0, 0.8); border-radius: 50%; padding: 4px; display: flex; align-items: center; justify-content: center; }
        /* --- Modal 彈出視窗樣式 --- */
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: flex; justify-content: center; align-items: center; z-index: 1050; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal-backdrop.show { opacity: 1; visibility: visible; }
        .param-list { list-style: none; padding-left: 0; margin-top: 1rem; color: #d1d5db; }
        .param-item { font-size: 0.875rem; margin-bottom: 0.5rem; }
        .param-item strong { color: #f7fafc; min-width: 120px; display: inline-block; }
        .param-group-title { font-weight: bold; color: #a5b4fc; margin-top: 1.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid #4b5563; }
        #month-year-picker { max-width: 320px; }
        #month-year-picker .year-nav { display: flex; justify-content: space-between; align-items: center; }
        #month-year-picker .month-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
        #month-year-picker .month-cell { padding: 8px; text-align: center; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; gap: 2px; }
        #month-year-picker .month-cell:hover { background-color: var(--bg-hover); }
        #month-year-picker .month-cell.selected { background-color: #4f46e5; color: white; }
        #month-year-picker .month-cell.selected * { color: white !important; fill: white !important; }
        /* --- UI 按鈕與工具列 --- */
        .action-buttons { position: fixed; bottom: 1rem; right: 1rem; display: flex; gap: 0.5rem; z-index: 1000; opacity: 1; transition: opacity 0.5s ease-in-out; }
        .action-buttons.hidden { opacity: 0; pointer-events: none; }
        .action-button { background-color: transparent; border: 1px solid rgba(75, 85, 99, 0.8); color: #d1d5db; width: 48px; height: 48px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s, color 0.2s, border-color 0.2s; box-shadow: none; }
        .action-button:hover { background-color: rgba(75, 85, 99, 0.3); color: white; border-color: #9ca3af;}
        #edit-toolbar { position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%); background-color: rgba(17, 24, 39, 0.9); border: 1px solid #374151; border-radius: 12px; padding: 8px; display: flex; align-items: center; gap: 8px; z-index: 1001; transition: bottom 0.3s ease-in-out; box-shadow: 0 -4px 15px rgba(0,0,0,0.3); user-select: none; }
        #edit-toolbar.show { bottom: 20px; }
        #toolbar-title { cursor: move; padding: 4px 8px; color: #9ca3af; }
        .toolbar-btn { background-color: transparent; border: 1px solid #4b5563; color: #d1d5db; padding: 6px 12px; border-radius: 8px; cursor: pointer; font-size: 14px; box-shadow: none; }
        .toolbar-btn:hover:not(:disabled) { background-color: rgba(75, 85, 99, 0.3); border-color: #9ca3af; }
        .toolbar-btn:disabled { color: #6b7280; cursor: not-allowed; border-color: #374151; }
        select, input[type="text"], textarea, input[type="range"] { background-color: #374151; border: 1px solid #4b5563; border-radius: 6px; color: #d1d5db; padding: 4px; }
        input[type="range"] { padding-left: 0; padding-right: 0; }
        input[type="color"] { padding: 2px; width: 40px; height: 30px; border: none; cursor: pointer; background-color: transparent; flex-shrink: 0; }
        .form-checkbox { appearance: none; background-color: #4b5563; border: 1px solid #6b7280; border-radius: 4px; width: 1.25em; height: 1.25em; position: relative; cursor: pointer; vertical-align: middle; }
        .form-checkbox:checked { background-color: #4f46e5; border-color: #4f46e5; }
        .form-checkbox:checked::after { content: '✓'; color: white; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.9em; }
        .form-checkbox:disabled { cursor: not-allowed; background-color: #374151; opacity: 0.6; }
        /* --- 編輯模式網格 --- */
        #edit-mode-grid { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-image: linear-gradient(to bottom, transparent 24px, rgba(0, 255, 255, 0.2) 24px, rgba(0, 255, 255, 0.2) 25px, transparent 25px), linear-gradient(to right, transparent 24px, rgba(0, 255, 255, 0.2) 24px, rgba(0, 255, 255, 0.2) 25px, transparent 25px); background-size: 50px 50px; background-position: center center; z-index: 9; pointer-events: none; }
        #edit-mode-grid::before, #edit-mode-grid::after { content: ''; position: absolute; background-color: rgba(255, 0, 255, 0.5); z-index: 9; }
        #edit-mode-grid::before { top: 0; left: 50%; width: 1px; height: 100%; transform: translateX(-50%); }
        #edit-mode-grid::after { top: 50%; left: 0; width: 100%; height: 1px; transform: translateY(-50%); }
        body.edit-mode #edit-mode-grid { display: block; }
        /* --- 由 Tailwind 轉換的語意化 CSS (部分保留) --- */
        .display-flex { display: flex; }
        .align-items-center { align-items: center; }
        .justify-content-space-between { justify-content: space-between; }
        .justify-content-center { justify-content: center; }
        .justify-content-flex-end { justify-content: flex-end; }
        .justify-content-start { justify-content: flex-start; }
        .align-items-flex-start { align-items: flex-start; }
        .flex-direction-column { flex-direction: column; }
        .flex-wrap { flex-wrap: wrap; }
        .flex-shrink-0 { flex-shrink: 0; }
        .flex-grow-1 { flex-grow: 1; }
        .display-grid { display: grid; }
        .grid-columns-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        .grid-columns-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        .grid-column-span-2 { grid-column: span 2 / span 2; }
        .p0 { padding: 0; margin: 0; }
        .padding-1 { padding: 0.25rem; }
        .padding-2 { padding: 0.5rem; }
        .padding-1_5 { padding: 0.375rem; }
        .padding-3 { padding: 0.75rem; }
        .padding-5 { padding: 1.25rem; }
        .padding-6 { padding: 1.5rem; }
        .padding-top-1 { padding-top: 0.25rem; }
        .padding-bottom-2 { padding-bottom: 0.5rem; }
        .padding-bottom-4 { padding-bottom: 1rem; }
        .padding-right-2 { padding-right: 0.25rem; }
        .padding-horizontal-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .padding-vertical-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .padding-vertical-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .margin-bottom-2 { margin-bottom: 0.5rem; }
        .margin-bottom-3 { margin-bottom: 0.75rem; }
        .margin-bottom-4 { margin-bottom: 1rem; }
        .margin-bottom-6 { margin-bottom: 1.5rem; }
        .margin-left-2 { margin-left: 0.5rem; }
        .margin-top-1 { margin-top: 0.25rem; }
        .margin-top-2 { margin-top: 0.5rem; }
        .margin-top-4 { margin-top: 1rem; }
        .margin-top-6 { margin-top: 1.5rem; }
        .gap-2 { gap: 0.5rem; }
        .gap-3 { gap: 0.75rem; }
        .gap-4 { gap: 1rem; }
        .column-gap-6 { column-gap: 1.5rem; }
        .column-gap-8 { column-gap: 2rem; }
        .row-gap-3 { row-gap: 0.75rem; }
        .row-gap-6 { row-gap: 1.5rem; }
        .space-y-2 > :not([hidden]) ~ :not([hidden]) { margin-top: 0.5rem; }
        .space-y-3 > :not([hidden]) ~ :not([hidden]) { margin-top: 0.75rem; }
        .space-x-2 > :not([hidden]) ~ :not([hidden]) { margin-left: 0.5rem; }
        .width-5 { width: 1.25rem; }
        .height-5 { height: 1.25rem; }
        .width-6 { width: 1.5rem; }
        .height-6 { height: 1.5rem; }
        .width-16 { width: 4rem; }
        .height-16 { height: 4rem; }
        .width-40 { width: 10rem; }
        .width-full { width: 100%; }
        .height-full { height: 100%; }
        .width-auto { width: auto; }
        .min-width-200px { min-width: 200px; }
        .max-width-sm { max-width: 24rem; }
        .max-width-md { max-width: 28rem; }
        .max-width-5xl { max-width: 64rem; }
        .max-height-80 { max-height: 20rem; }
        .max-height-90vh { max-height: 90vh; }
        .font-weight-bold { font-weight: 700; }
        .font-weight-semibold { font-weight: 600; }
        .font-size-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .font-size-md { font-size: 1rem; line-height: 1.5rem; }
        .font-size-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .font-size-xl { font-size: 1.25rem; line-height: 1.75rem; }
        .font-size-3xl { font-size: 1.875rem; line-height: 2.25rem; }
        .line-height-none { line-height: 1; }
        .line-height-relaxed { line-height: 1.625; }
        .text-align-center { text-align: center; }
        .color-white { color: #ffffff; }
        .color-gray-300 { color: #d1d5db; }
        .color-gray-400 { color: #9ca3af; }
        .color-indigo-300 { color: #a5b4fc; }
        .bg-gray-800 { background-color: #1f2937; }
        .border-top-1px { border-top-width: 1px; }
        .border-bottom-1px { border-bottom-width: 1px; }
        .border-color-gray-600 { border-color: #4b5563; }
        .border-color-gray-700 { border-color: #374151; }
        .border-radius-lg { border-radius: 0.5rem; }
        .cursor-pointer { cursor: pointer; }
        .cursor-help { cursor: help; }
        .hover-color-white:hover { color: #ffffff; }
        .display-none { display: none !important; }
        .overflow-hidden { overflow: hidden; }
        .overflow-y-auto { overflow-y: auto; }
        .position-relative { position: relative; }
        /* --- 全域按鈕樣式重置 --- */
        #calendar-container button, #moon-phase-container button,
        .action-button, .toolbar-btn, [data-close-modal],
        #useCurrentLocationBtn, #marquee-params-btn, #default-settings-btn, #random-colors-btn,
        #picker-prev-year, #picker-next-year, #prompt-cancel-btn, #prompt-ok-btn {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            color: #d1d5db;
            transition: color 0.2s, background-color 0.2s;
        }
        #calendar-container button:hover, #moon-phase-container button:hover,
        .toolbar-btn:hover:not(:disabled), [data-close-modal]:hover,
        #useCurrentLocationBtn:hover, #marquee-params-btn:hover, #default-settings-btn:hover,
        #random-colors-btn:hover, #picker-prev-year:hover, #picker-next-year:hover,
        #prompt-cancel-btn:hover, #prompt-ok-btn:hover, .action-button:hover {
            color: #ffffff !important;
        }
        /* 為圓形或有圓角的按鈕提供懸停時的背景回饋 */
        .action-button:hover, #useCurrentLocationBtn:hover, #marquee-params-btn:hover,
        #picker-prev-year:hover, #picker-next-year:hover, .calendar-widget .calendar-nav-arrow:hover {
            background-color: rgba(75, 85, 99, 0.3) !important;
        }
        .action-button { display: inline-flex; align-items: center; justify-content: center; padding: 0; margin: 0; }

        /* 視覺對齊修正 */
        #modal-backdrop-settings .space-y-3 > div,
        #modal-backdrop-settings .p0 > .display-flex.justify-content-space-between {
            align-items: center;
        }

        #modal-backdrop-settings .display-flex.align-items-center.gap-3 > .display-flex.align-items-center.gap-2 {
            align-items: center;
        }
        
        #modal-backdrop-settings label[for="marquee-vertical-toggle"],
        #modal-backdrop-settings label[for="marquee-use-led-font-toggle"] {
            display: flex;
            align-items: center;
        }

        @media (min-width: 768px) {
            .md-grid-columns-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
            .md-grid-columns-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
            .md-grid-column-span-2 { grid-column: span 2 / span 2; }
        }
        @media (min-width: 1024px) {
            .lg-grid-columns-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        }
    </style>
</head>
<body class="antialiased">
    <svg style="display: none;">
        <defs>
            <symbol id="icon-move" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3M2 12h20M12 2v20"></path>
            </symbol>
            <symbol id="icon-reset-size" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <text x="5" y="17" font-size="12" font-weight="bold" fill="currentColor" stroke="none">1x</text>
                <rect x="2" y="4" width="20" height="16" rx="2"></rect>
            </symbol>
            <symbol id="icon-rotate" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 4v6h-6"></path>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </symbol>
             <symbol id="icon-scale" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                <path d="M3 9V5a2 2 0 0 1 2-2h4" />
                <path d="M15 3h4a2 2 0 0 1 2 2v4" />
                <path d="m14 10-5.5 5.5" />
                <path d="M14 14v-4h-4" />
            </symbol>
            <symbol id="icon-checkbox-unchecked" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            </symbol>
            <symbol id="icon-checkbox-checked" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <path d="M9 12l2 2 4-4"></path>
            </symbol>
        </defs>
    </svg>
    <div id="edit-mode-grid"></div>
    <div id="calendar-container" class="widget-container calendar-widget">
        <div class="widget-content-wrapper">
            <div id="background-month" class="background-month"></div>
            <header class="calendar-header">
                <h1 id="year-header" class="calendar-title" title="點擊快速選擇年月"></h1>
                <div class="calendar-nav">
                    <button id="prev-month" class="calendar-nav-arrow">
                        <svg class="height-6 width-6" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
                    </button>
                    <button id="back-to-today" class="calendar-nav-today">今天</button>
                    <button id="next-month" class="calendar-nav-arrow">
                        <svg class="height-6 width-6" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                    </button>
                </div>
            </header>
            <main class="padding-bottom-2 position-relative" style="z-index: 2;">
                <div class="calendar-grid">
                    <div class="day-header">日</div><div class="day-header">一</div><div class="day-header">二</div><div class="day-header">三</div><div class="day-header">四</div><div class="day-header">五</div><div class="day-header">六</div>
                </div>
                <div id="calendar-body" class="calendar-grid"></div>
            </main>
        </div>
    </div>
    <div id="led-clock-container" class="widget-container">
        <div class="widget-content-wrapper">
            <main>
                <svg id="led-clock-svg" viewBox="0 0 1200 350"></svg>
            </main>
        </div>
    </div>
    <div id="analog-clock-container" class="widget-container">
        <div class="widget-content-wrapper">
            <main class="analog-clock-face">
                <div class="ticks-container" id="ticks-container"></div>
                <div class="analog-hand hour-hand"></div>
                <div class="analog-hand minute-hand"></div>
                <div class="analog-hand second-hand"></div>
                <div class="analog-pivot"></div>
            </main>
        </div>
    </div>
    <div id="marquee-container-0" class="widget-container marquee-widget">
        <div class="widget-content-wrapper"><main><div class="marquee-inner"></div></main></div>
    </div>
    <div id="moon-phase-container" class="widget-container calendar-widget">
        <div class="widget-content-wrapper">
            <div id="moon-background-month" class="background-month"></div>
            <header class="calendar-header">
                <h1 id="moon-phase-year-header" class="calendar-title" title="點擊快速選擇年月"></h1>
                <div class="calendar-nav">
                    <button id="moon-phase-prev-month" class="calendar-nav-arrow"><svg class="height-6 width-6" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg></button>
                    <button id="moon-phase-today" class="calendar-nav-today">今天</button>
                    <button id="moon-phase-next-month" class="calendar-nav-arrow"><svg class="height-6 width-6" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg></button>
                </div>
            </header>
            <main class="padding-bottom-2 position-relative" style="z-index: 2;">
                <div class="calendar-grid">
                    <div class="day-header">日</div><div class="day-header">一</div><div class="day-header">二</div><div class="day-header">三</div><div class="day-header">四</div><div class="day-header">五</div><div class="day-header">六</div>
                </div>
                <div id="moon-calendar-body" class="calendar-grid"></div>
            </main>
        </div>
    </div>
    <div id="action-buttons" class="action-buttons">
        <button id="edit-layout-btn" class="action-button" title="編輯版面">
            <svg id="edit-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>
            <svg id="edit-exit-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="display-none"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
        <button id="settings-btn" class="action-button" title="設定">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
        </button>
        <button id="fullscreen-btn" class="action-button" title="全螢幕">
            <svg id="fullscreen-enter-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
            <svg id="fullscreen-exit-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="display-none"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path></svg>
        </button>
    </div>
    <div id="edit-toolbar">
        <span id="toolbar-title" title="按住拖曳">☰</span>
        <select id="layout-selector"></select>
        <button id="save-layout-btn" class="toolbar-btn" title="新增存檔">+</button>
        <button id="delete-layout-btn" class="toolbar-btn" title="刪除目前存檔">-</button>
        <button id="load-layout-btn" class="toolbar-btn">載入</button>
        <button id="export-layout-btn" class="toolbar-btn">導出</button>
        <button id="import-layout-btn" class="toolbar-btn">導入</button>
    </div>
    <div id="modal-backdrop-day" class="modal-backdrop"><div class="modal-content max-width-md"><div class="padding-6"><div class="display-flex justify-content-space-between align-items-flex-start margin-bottom-4"><div><h2 id="modal-gregorian-date" class="font-size-xl font-weight-bold color-white"></h2><p id="modal-lunar-date" class="font-size-md color-indigo-300"></p><p id="modal-constellation" class="font-size-md color-gray-400 margin-top-1"></p><p id="modal-holiday" class="font-size-md holiday-text margin-top-1 cursor-help"></p><p id="modal-solarterm" class="font-size-md solarterm-text cursor-help"></p></div><button data-close-modal="modal-backdrop-day" class="color-gray-400 hover-color-white font-size-3xl line-height-none">&times;</button></div><div class="p0 text-align-center"><p id="countdown-holiday-text" class="font-size-sm color-gray-300"></p><p id="countdown-solarterm-text" class="font-size-sm color-gray-300"></p></div>
<div id="modal-day-details-grid" class="margin-top-4 display-grid grid-columns-2 gap-4 text-align-center">
    <div>
        <p class="font-size-sm color-gray-400">日出</p>
        <p id="modal-sunrise-time" class="font-size-lg font-weight-semibold color-white"></p>
    </div>
    <div>
        <p class="font-size-sm color-gray-400">日落</p>
        <p id="modal-sunset-time" class="font-size-lg font-weight-semibold color-white"></p>
    </div>
    <div class="grid-column-span-2 display-flex align-items-center justify-content-center gap-4 padding-top-1 margin-top-2 border-top-1px border-color-gray-700">
         <div id="modal-moon-icon" class="width-16 height-16"></div>
         <div>
            <p class="font-size-sm color-gray-400">當日月相</p>
            <p id="modal-moon-phase-name" class="font-size-lg font-weight-semibold color-white"></p>
            <p id="modal-moon-phase-desc" class="font-size-sm color-gray-300 margin-top-1"></p>
         </div>
    </div>
</div>
</div></div></div>
    <div id="modal-backdrop-picker" class="modal-backdrop"><div id="month-year-picker" class="modal-content"><div class="padding-5"><div class="year-nav margin-bottom-4"><button id="picker-prev-year" class="calendar-nav-arrow">&lt;</button><span id="picker-year" class="font-size-xl font-weight-bold">2024</span><button id="picker-next-year" class="calendar-nav-arrow">&gt;</button></div><div id="picker-month-grid" class="month-grid"></div></div></div></div>
    <div id="modal-backdrop-settings" class="modal-backdrop">
        <div class="modal-content max-width-5xl max-height-90vh display-flex flex-direction-column">
            <div class="p0" style="position: sticky; top: 0; z-index: 1;">
                <div class="display-flex justify-content-space-between align-items-center">
                    <h3 class="font-size-xl font-weight-bold color-indigo-300 p0">設定</h3>
                    <div class="display-flex align-items-center gap-3">
                        <button id="default-settings-btn" class="toolbar-btn font-size-sm padding-horizontal-3 padding-vertical-1">恢復預設</button>
                        <button id="random-colors-btn" class="toolbar-btn font-size-sm padding-horizontal-3 padding-vertical-1">隨機顏色</button>
                        <button data-close-modal="modal-backdrop-settings" class="color-gray-400 hover-color-white font-size-3xl line-height-none">&times;</button>
                    </div>
                </div>
            </div>
            <div class="overflow-y-auto padding-5">
                <div class="p0">
                     <div class="display-grid grid-columns-1 md-grid-columns-2 lg-grid-columns-4 column-gap-6 row-gap-6">
                        <div>
                            <h4 class="p0">
                                <input type="checkbox" data-widget-toggle="calendar-container" class="form-checkbox">
                                <span class="font-size-lg font-weight-semibold">月曆</span>
                            </h4>
                                <div class="p0">
                                    <input type="checkbox" id="calendar-use-led-font-toggle" class="form-checkbox" data-setting-type="toggle" data-widget="calendar" data-key="useLedFont">
                                    <label for="calendar-use-led-font-toggle" class="cursor-pointer">LED 字型</label>
                                    <input type="checkbox" id="calendar-show-moon-icon-toggle" class="form-checkbox" data-setting-type="toggle" data-widget="calendar" data-key="showMoonIcon">
                                    <label for="calendar-show-moon-icon-toggle" class="cursor-pointer">顯示月相</label>
                                </div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>背景</label><input type="color" class="color-picker" data-setting-type="color" data-widget="calendar" data-var="--bg-primary"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>年</label><input type="color" class="color-picker" data-setting-type="color" data-widget="calendar" data-var="--year-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>月</label><input type="color" class="color-picker" data-setting-type="color" data-widget="calendar" data-var="--month-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>日</label><input type="color" class="color-picker" data-setting-type="color" data-widget="calendar" data-var="--day-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>星期</label><input type="color" class="color-picker" data-setting-type="color" data-widget="calendar" data-var="--week-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>農曆</label><input type="color" class="color-picker" data-setting-type="color" data-widget="calendar" data-var="--lunar-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>節日</label><input type="color" class="color-picker" data-setting-type="color" data-widget="calendar" data-var="--holiday-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>節氣</label><input type="color" class="color-picker" data-setting-type="color" data-widget="calendar" data-var="--solarterm-color"></div>
                            </div>
                        <div>
                            <h4 class="p0">
                                <input type="checkbox" data-widget-toggle="moon-phase-container" class="form-checkbox">
                                <span class="font-size-lg font-weight-semibold">月相月曆</span>
                            </h4>
                            <div class="space-y-3">
                                <input type="checkbox" id="moon-phase-use-led-font-toggle" class="form-checkbox" data-setting-type="toggle" data-widget="moonPhase" data-key="useLedFont">
                                <label for="moon-phase-use-led-font-toggle" class="cursor-pointer">LED 字型</label>
                                <div class="display-flex justify-content-space-between align-items-center"><label>亮部</label><input type="color" class="color-picker" data-setting-type="color" data-widget="moonPhase" data-var="--moon-light-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>暗部</label><input type="color" class="color-picker" data-setting-type="color" data-widget="moonPhase" data-var="--moon-dark-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>標題</label><input type="color" class="color-picker" data-setting-type="color" data-widget="moonPhase" data-var="--moon-header-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>描述</label><input type="color" class="color-picker" data-setting-type="color" data-widget="moonPhase" data-var="--moon-desc-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>高亮</label><input type="color" class="color-picker" data-setting-type="color" data-widget="moonPhase" data-var="--moon-highlight-color"></div>
                            </div>
                        </div>
                        <div>
                            <h4 class="p0">
                                <input type="checkbox" data-widget-toggle="led-clock-container" class="form-checkbox">
                                <span class="font-size-lg font-weight-semibold">LED 時鐘</span>
                            </h4>
                            <div class="space-y-3">
                                <div class="display-flex justify-content-space-between align-items-center"><label>時</label><input type="color" class="color-picker" data-setting-type="color" data-widget="ledClock" data-var="--led-hour-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>分</label><input type="color" class="color-picker" data-setting-type="color" data-widget="ledClock" data-var="--led-minute-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>秒</label><input type="color" class="color-picker" data-setting-type="color" data-widget="ledClock" data-var="--led-second-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>冒號</label>
                                <div class="p0">
                                    <input type="checkbox" id="led-clock-colon-blink-toggle" class="form-checkbox" data-setting-type="toggle" data-widget="ledClock" data-key="colonBlink">
                                    <label for="led-clock-colon-blink-toggle" class="cursor-pointer">閃爍</label>
                                <input type="color" class="color-picker" data-setting-type="color" data-widget="ledClock" data-var="--led-colon-color"></div>
                                </div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>時段</label><input type="color" class="color-picker" data-setting-type="color" data-widget="ledClock" data-var="--led-period-color"></div>
                            </div>
                        </div>
                        <div>
                            <h4 class="p0">
                                <input type="checkbox" data-widget-toggle="analog-clock-container" class="form-checkbox">
                                <span class="font-size-lg font-weight-semibold">指針時鐘</span>
                            </h4>
                            <div class="space-y-3">
                                    <input type="checkbox" id="analog-clock-use-led-font-toggle" class="form-checkbox" data-setting-type="toggle" data-widget="analogClock" data-key="useLedFont">
                                    <label for="analog-clock-use-led-font-toggle" class="cursor-pointer">LED 字型</label>
                                <div class="display-flex justify-content-space-between align-items-center"><label>指針</label><input type="color" class="color-picker" data-setting-type="color" data-widget="analogClock" data-var="--analog-hand-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>秒針</label>
                                <div class="p0">
                                    <input type="checkbox" id="analog-clock-smooth-seconds-toggle" class="form-checkbox" data-setting-type="toggle" data-widget="analogClock" data-key="smoothSeconds">
                                    <label for="analog-clock-smooth-seconds-toggle" class="cursor-pointer">平滑</label>
                                <input type="color" class="color-picker" data-setting-type="color" data-widget="analogClock" data-var="--analog-second-hand-color"></div>
                                </div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>刻度</label><input type="color" class="color-picker" data-setting-type="color" data-widget="analogClock" data-var="--analog-tick-color"></div>
                                <div class="display-flex justify-content-space-between align-items-center"><label>數字</label><input type="color" class="color-picker" data-setting-type="color" data-widget="analogClock" data-var="--analog-number-color"></div>
                            </div>
                        </div>
                </div>
                        <div class="grid-column-span-2 md-grid-column-span-2">
                            <div class="display-flex align-items-center justify-content-start width-full padding-vertical-2 p0 flex-wrap gap-3">
                                <div class="display-flex align-items-center gap-2">
                                    <input type="checkbox" id="timed-effect-enabled-toggle" class="form-checkbox">
                                    <label for="timed-effect-enabled-toggle" class="font-size-lg font-weight-semibold">定時特效</label>
                                </div>
                                <div class="display-flex align-items-center gap-2">
                                    <label for="timed-effect-interval-seconds">觸發間隔</label>
                                    <select id="timed-effect-interval-seconds"></select>
                                    <span>秒</span>
                                </div>
                                <div class="display-flex align-items-center gap-2">
                                    <label for="timed-effect-type">類型</label>
                                    <select id="timed-effect-type">
                                        <option value="slide">滑動</option>
                                        <option value="layoutSwitch">版面切換</option>
                                    </select>
                                </div>
                                <div class="display-flex align-items-center gap-3">
                                    <div id="layout-switch-options" class="display-flex align-items-center gap-2" style="display: none;">
                                        <input type="checkbox" id="layout-switch-random-toggle" class="form-checkbox">
                                        <label for="layout-switch-random-toggle" class="cursor-pointer">亂數</label>
                                    </div>
                                    <div class="display-flex align-items-center gap-2">
                                        <input type="checkbox" id="transition-effect-enabled-toggle" class="form-checkbox">
                                        <label for="transition-effect-enabled-toggle" class="cursor-pointer">轉場特效</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                     </div>
                <div class="p0">
                    <div class="display-grid grid-columns-1 md-grid-columns-2 gap-4 align-items-center">
                        <div class="display-flex flex-direction-column row-gap-3 flex-shrink-0">
                            <div class="display-flex align-items-center column-gap-6 flex-wrap">
                                <div class="display-flex align-items-center gap-2">
                                    <input type="checkbox" id="marquee-enabled-toggle" class="form-checkbox" title="啟用/停用目前選擇的跑馬燈">
                                    <label for="marquee-enabled-toggle" class="font-size-lg font-weight-semibold">跑馬燈</label>
                                </div>
                                <div class="display-flex align-items-center">
                                    <label for="marquee-selector" class="flex-shrink-0">組別:</label>
                                    <select id="marquee-selector" class="width-auto margin-left-2"></select>
                                    <button id="add-marquee-btn" class="toolbar-btn margin-left-2" style="padding: 4px 8px; font-size: 16px;" title="新增跑馬燈">+</button>
                                    <button id="remove-marquee-btn" class="toolbar-btn margin-left-2" style="padding: 4px 8px; font-size: 16px;" title="刪除跑馬燈">-</button>
                                </div>
                                <div class="display-flex align-items-center column-gap-2 flex-grow-1 min-width-200px">
                                    <label for="marquee-speed-input" class="flex-shrink-0">速度</label>
                                    <input type="range" id="marquee-speed-input" min="1" max="1000" class="width-full">
                                </div>
                                <div class="display-flex align-items-center column-gap-4">
                                    <label class="display-flex align-items-center space-x-2 cursor-pointer flex-shrink-0"><input type="checkbox" id="marquee-vertical-toggle" class="form-checkbox"><span>直向</span></label>
                                    <div class="display-flex align-items-center">
                                        <label for="marquee-direction-select" class="flex-shrink-0 padding-right-2">方向:</label>
                                        <select id="marquee-direction-select"></select>
                                    </div>
                                    <div class="display-flex align-items-center column-gap-2">
                                        <label for="marquee-default-color">顏色</label>
                                        <input type="color" id="marquee-default-color" class="color-picker">
                                    </div>
                                     <div class="display-flex align-items-center gap-2">
                                        <input type="checkbox" id="marquee-use-led-font-toggle" class="form-checkbox" data-setting-type="toggle" data-widget="marqueeGlobal" data-key="useLedFont">
                                        <label for="marquee-use-led-font-toggle" class="cursor-pointer">LED 字型</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="display-flex align-items-center justify-content-flex-end gap-2 flex-wrap">
                            <label class="flex-shrink-0">地區</label>
                            <select id="countySelect"></select>
                            <select id="districtSelect"></select>
                            <input id="manualLocationInput" type="text" placeholder="手動輸入英文地名" class="width-40">
                            <button id="useCurrentLocationBtn" class="padding-1_5 border-radius-lg flex-shrink-0" title="使用目前位置">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L12 6"/><path d="M12 18L12 22"/><path d="M20 12L22 12"/><path d="M2 12L4 12"/><circle cx="12" cy="12" r="2"/><path d="M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16z"/></svg>
                            </button>
                        </div>
                    </div>
                    <div class="margin-top-4 grid-column-span-2 display-flex align-items-flex-start">
                       <label for="marquee-text-input" class="flex-shrink-0 padding-top-1" style="margin-right: 0.75rem;">內容</label>
                       <div class="display-flex align-items-flex-start width-full">
                           <textarea id="marquee-text-input" class="width-full" rows="3"></textarea>
                           <button id="marquee-params-btn" class="margin-left-2 padding-1_5 border-radius-lg flex-shrink-0" title="顯示可用參數">
                               <svg xmlns="http://www.w3.org/2000/svg" class="height-5 width-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" /></svg>
                           </button>
                       </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="modal-backdrop-explanation" class="modal-backdrop"><div class="modal-content max-width-sm"><div class="padding-6"><div class="display-flex justify-content-space-between align-items-center margin-bottom-3"><h3 id="explanation-title" class="font-size-xl font-weight-bold color-indigo-300"></h3><button data-close-modal="modal-backdrop-explanation" class="color-gray-400 hover-color-white font-size-3xl line-height-none">&times;</button></div><p id="explanation-content" class="color-gray-300 line-height-relaxed"></p></div></div></div>
    <div id="modal-backdrop-prompt" class="modal-backdrop"><div class="modal-content max-width-sm"><div class="padding-6"><h3 id="prompt-title" class="font-size-xl font-weight-bold color-indigo-300 margin-bottom-4"></h3><p id="prompt-message" class="color-gray-300 margin-bottom-4"></p><input id="prompt-input" type="text" class="width-full margin-bottom-4"><div class="display-flex justify-content-flex-end gap-2"><button id="prompt-cancel-btn" class="toolbar-btn">取消</button><button id="prompt-ok-btn" class="toolbar-btn">確定</button></div></div></div></div>
    <div id="modal-backdrop-marquee-params" class="modal-backdrop">
        <div class="modal-content max-width-md">
            <div class="padding-6">
                <div class="display-flex justify-content-space-between align-items-center">
                    <h3 class="font-size-xl font-weight-bold color-indigo-300 p0">跑馬燈可用參數列表</h3>
                    <button data-close-modal="modal-backdrop-marquee-params" class="color-gray-400 hover-color-white font-size-3xl line-height-none">&times;</button>
                </div>
                <ul class="param-list max-height-80 overflow-y-auto padding-right-2">
                    <li class="param-group-title">特殊功能</li>
                    <li class="param-item"><strong>%C(#RRGGBB, 文字)%</strong>: 自訂文字顏色。例如: %C(#FFD700, 黃色文字)%</li>
                    <li class="param-item"><strong>%br%</strong>: (僅直向)手動換行</li>
                    <li class="param-item"><strong>提示:</strong> %C(...)% 參數中的文字部分不能再包含其他參數。系統會自動為時間、天氣等參數套用主題色彩。</li>
                    <li class="param-group-title">西元日期與時間</li>
                    <li class="param-item"><strong>%YYYY%</strong>: 四位數西元年 (例如: 2024)</li>
                    <li class="param-item"><strong>%YY%</strong>: 兩位數西元年 (例如: 24)</li>
                    <li class="param-item"><strong>%ROC_YY%</strong>: 民國年 (例如: 113)</li>
                    <li class="param-item"><strong>%MM%</strong>: 兩位數月份 (例如: 09)</li>
                    <li class="param-item"><strong>%M%</strong>: 月份，無前導零 (例如: 9)</li>
                    <li class="param-item"><strong>%DD%</strong>: 兩位數日期 (例如: 08)</li>
                    <li class="param-item"><strong>%D%</strong>: 日期，無前導零 (例如: 8)</li>
                    <li class="param-item"><strong>%WEEKDAY%</strong>: 星期全名 (例如: 星期日)</li>
                    <li class="param-item"><strong>%W_SHORT%</strong>: 星期簡稱 (例如: 週日)</li>
                    <li class="param-item"><strong>%W_CHAR%</strong>: 星期單字 (例如: 日)</li>
                    <li class="param-item"><strong>%W_NUM%</strong>: 星期數字 (0 為星期日)</li>
                    <li class="param-item"><strong>%CONSTELLATION%</strong>: 當日星座 (例如: 處女座)</li>
                    <li class="param-item"><strong>%HH%</strong>: 24小時制，兩位數 (例如: 23)</li>
                    <li class="param-item"><strong>%H%</strong>: 24小時制，無前導零 (例如: 23)</li>
                    <li class="param-item"><strong>%hh%</strong>: 12小時制，兩位數 (例如: 11)</li>
                    <li class="param-item"><strong>%h%</strong>: 12小時制，無前導零 (例如: 11)</li>
                    <li class="param-item"><strong>%mm%</strong>: 分鐘，兩位數 (例如: 05)</li>
                    <li class="param-item"><strong>%m%</strong>: 分鐘，無前導零 (例如: 5)</li>
                    <li class="param-item"><strong>%ss%</strong>: 秒數，兩位數 (例如: 01)</li>
                    <li class="param-item"><strong>%s%</strong>: 秒數，無前導零 (例如: 1)</li>
                    <li class="param-item"><strong>%ap_c%</strong>: 中文時段 (例如: 上午, 下午)</li>
                    <li class="param-item"><strong>%AP%</strong>: 英文時段，大寫 (AM/PM)</li>
                    <li class="param-item"><strong>%ap%</strong>: 英文時段，小寫 (am/pm)</li>
                    <li class="param-group-title">農曆與生肖</li>
                    <li class="param-item"><strong>%L_GZ%</strong>: 農曆年干支 (例如: 甲辰)</li>
                    <li class="param-item"><strong>%L_SX%</strong>: 生肖 (例如: 龍)</li>
                    <li class="param-item"><strong>%LM_C%</strong>: 農曆中文月份 (例如: 八月)</li>
                    <li class="param-item"><strong>%LD_C%</strong>: 農曆中文日期 (例如: 初三)</li>
                    <li class="param-group-title">時辰</li>
                    <li class="param-item"><strong>%SHICHEN_GZ%</strong>: 時辰干支 (例如: 甲子)</li>
                    <li class="param-item"><strong>%SHICHEN_NAME%</strong>: 時辰全名 (例如: 子時)</li>
                    <li class="param-item"><strong>%SHICHEN_CHAR%</strong>: 時辰地支 (例如: 子)</li>
                    <li class="param-group-title">月相</li>
                    <li class="param-item"><strong>%MOON_PHASE%</strong>: 當日月相名稱 (例: 望月(滿月))</li>
                    <li class="param-item"><strong>%MOON_ICON%</strong>: 當日月相圖示 (SVG圖示)</li>
                    <li class="param-item"><strong>%MOON_DAY%</strong>: 農曆日期 (數字, 1-30)</li>
                    <li class="param-group-title">天氣資訊</li>
                    <li class="param-item"><strong>%WEATHER_LOC%</strong>: 地點</li>
                    <li class="param-item"><strong>%WEATHER_DESC%</strong>: 天氣描述 (例如: 晴)</li>
                    <li class="param-item"><strong>%TEMP%</strong>: 氣溫(°C)</li>
                    <li class="param-item"><strong>%SUNRISE%</strong>: 日出時間 (HH:mm)</li>
                    <li class="param-item"><strong>%SUNSET%</strong>: 日落時間 (HH:mm)</li>
                </ul>
            </div>
        </div>
    </div>
    <script>
        // --- 全域變數與常數 ---
        const STORAGE_AUTOSAVE_KEY = 'widgets_autosave';
        const STORAGE_LAYOUTS_KEY = 'widgets_layouts_v2';
        let weatherDataLoaded = false;
        let layouts = [];
        let currentLayoutIndex = -1; // -1 表示目前狀態未對應任何已儲存的版面，或是已被修改
        let nextLayoutIndex = 0; // 用於循序版面切換

        document.addEventListener('DOMContentLoaded', function () {
            // ===================================================================
            // 月曆與月相曆模組 (工廠模式)
            // ===================================================================
            function createCalendarWidget(options) {
                const { bodyId, yearHeaderId, backgroundMonthId, prevBtnId, nextBtnId, todayBtnId, onCellRender, onHeaderClick, getSetting } = options;
                const body = document.getElementById(bodyId), yearHeader = document.getElementById(yearHeaderId), backgroundMonth = document.getElementById(backgroundMonthId);
                const widget = {
                    body: body, currentDate: new Date(),
                    init() {
                        document.getElementById(prevBtnId).addEventListener('click', () => { if (!isEditMode) { this.currentDate.setMonth(this.currentDate.getMonth() - 1); this.render(); } });
                        document.getElementById(nextBtnId).addEventListener('click', () => { if (!isEditMode) { this.currentDate.setMonth(this.currentDate.getMonth() + 1); this.render(); } });
                        document.getElementById(todayBtnId).addEventListener('click', () => { if (!isEditMode) { this.currentDate = new Date(); this.render(); } });
                        if (onHeaderClick) yearHeader.addEventListener('click', () => onHeaderClick(this));
                        this.render();
                    },
                    render() {
                        body.innerHTML = '';
                        const year = this.currentDate.getFullYear(), month = this.currentDate.getMonth();
                        const widgetSettings = getSetting() || {};
                        const useLedHeader = widgetSettings.useLedFont ?? true;
                        const yearColor = getComputedStyle(document.documentElement).getPropertyValue('--year-color').trim() || '#FF7000';
                        renderCalendarTitle(yearHeader, year, useLedHeader, 26, yearColor, '26px', yearColor);
                        const widgetId = body.closest('.widget-container').id;
                        const widgetState = transformStates[widgetId];
                        if (useLedHeader && widgetState) {
                             const monthColor = getComputedStyle(document.documentElement).getPropertyValue('--month-color').trim() || '#3070a0';
                             backgroundMonth.innerHTML = generateLedSvg(String(month + 1), { height: widgetState.height * 0.7, color: monthColor });
                        } else {
                             backgroundMonth.textContent = month + 1;
                        }
                        const firstDayOfMonth = new Date(year, month, 1);
                        const startDayOfWeek = firstDayOfMonth.getDay();
                        const startDate = new Date(year, month, 1 - startDayOfWeek);
                        const today = new Date(); today.setHours(0, 0, 0, 0);
                        for (let i = 0; i < 42; i++) {
                            const currentCellDate = new Date(startDate);
                            currentCellDate.setDate(startDate.getDate() + i);
                            const cell = document.createElement('div');
                            cell.className = `calendar-day ${currentCellDate.getMonth() !== month ? 'other-month' : ''} ${currentCellDate.getTime() === today.getTime() ? 'today' : ''}`;
                            onCellRender(cell, currentCellDate, widgetSettings);
                            body.appendChild(cell);
                        }
                    }
                };
                return widget;
            }
            const calendarCellRenderer = (cell, date, settings) => {
                const day = date.getDate(), lunar = getLunarDate(date), solarTerm = getSolarTerm(date.getFullYear(), date.getMonth() + 1, day), holiday = getHoliday(date);
                const showMoonIcon = settings.showMoonIcon ?? true, useLed = settings.useLedFont ?? true;
                const textDetailsHTML = `<div class="lunar-date">${lunar.day === 1 ? lunar.toString.substring(0, lunar.isLeap ? 3 : 2) : lunar.dayString}</div>
                    ${solarTerm ? `<div class="solarterm-text truncate" data-key="${solarTerm}">${solarTerm}</div>` : ''}
                    ${holiday ? `<div class="holiday-text truncate" data-key="${holiday}">${holiday}</div>` : ''}`;
                const dayColor = getComputedStyle(document.documentElement).getPropertyValue('--day-color').trim();
                const dayNumberHTML = useLed ? `<div class="day-number-wrapper">${generateLedSvg(String(day), {height: 20, color: dayColor})}</div>` : `<div class="day-number-wrapper" style="font-size: 1.5em; line-height: 1.2; color: ${dayColor}; display: flex; align-items: center; justify-content: center; height: 20px; font-weight: 700;">${day}</div>`;
                if (showMoonIcon) {
                    cell.classList.add('with-moon-icon');
                    cell.innerHTML = `<div class="day-text-content">${dayNumberHTML}<div class="space-y-px">${textDetailsHTML}</div></div><div class="day-moon-container">${MoonPhaseWidget.getMoonPhaseSVG(lunar.day, '28px', `main-cal-${Math.random()}`)}</div>`;
                } else {
                    cell.classList.remove('with-moon-icon');
                    cell.innerHTML = `${dayNumberHTML}<div class="space-y-px">${textDetailsHTML}</div>`;
                }
                cell.dataset.date = date.toISOString();
                if (isEditMode) cell.classList.add('edit-mode-active');
            };
            const moonPhaseCellRenderer = (cell, date, settings) => {
                const lunar = getLunarDate(date), useLed = settings.useLedFont ?? true, dayColor = getComputedStyle(document.documentElement).getPropertyValue('--day-color').trim() || '#ffffff', day = date.getDate();
                const dayNumberHTML = useLed ? `<div class="day-number-wrapper">${generateLedSvg(String(day), { height: 20, color: dayColor })}</div>` : `<div class="day-number-wrapper" style="font-size: 1.2em; line-height: 1; color: ${dayColor}; font-weight: bold;">${day}</div>`;
                const lunarDateText = lunar.day === 1 ? lunar.toString.substring(0, lunar.isLeap ? 3 : 2) : lunar.dayString;
                cell.innerHTML = `${dayNumberHTML}<div class="moon-icon-small">${MoonPhaseWidget.getMoonPhaseSVG(lunar.day, '100%', `grid-${Math.random()}`)}</div><div class="lunar-date">${lunarDateText}</div>`;
                cell.addEventListener('click', () => { if(!isEditMode) showDayDetailModal(date.toISOString()); });
            };
            // ===================================================================
            // 設定、顏色與儲存
            // 說明: 處理所有設定的載入、套用和儲存邏輯。
            // ===================================================================
            function applyDefaultSettings() { applyLayout(JSON.parse(JSON.stringify(userDefaultLayout))); saveCurrentSettings(); Weather.updateWeather(); }
            function applyAllSettings() {
                Object.values(settingsState).forEach(widgetState => {
                    if (widgetState && widgetState.colors) Object.entries(widgetState.colors).forEach(([key, value]) => document.documentElement.style.setProperty(key, value));
                });
                applyAllTransforms();
                updateSettingsUIFromState();
                Calendar.render();
                MoonPhaseWidget.render();
                AnalogClock.init();
                MarqueeManager.rebuildAllAnimations();
            }
            function saveCurrentSettings(isProgrammaticChange = false) {
                localStorage.setItem(STORAGE_AUTOSAVE_KEY, JSON.stringify({ transforms: transformStates, settings: settingsState }));
                if (!isProgrammaticChange) {
                    currentLayoutIndex = -1;
                }
            }
            function updateSettingsUIFromState() {
                document.querySelectorAll('#modal-backdrop-settings input[data-setting-type="color"]').forEach(picker => {
                    const widget = picker.dataset.widget, cssVar = picker.dataset.var;
                    picker.value = settingsState[widget]?.colors?.[cssVar] || getComputedStyle(document.documentElement).getPropertyValue(cssVar).trim() || '#ffffff';
                });
                document.querySelectorAll('input[data-widget-toggle]').forEach(toggle => { toggle.checked = transformStates[toggle.dataset.widgetToggle]?.visible ?? false; });
                document.querySelectorAll('#modal-backdrop-settings input[data-setting-type="toggle"]').forEach(toggle => {
                    const widget = toggle.dataset.widget, key = toggle.dataset.key;
                    if (settingsState[widget] && typeof settingsState[widget][key] !== 'undefined') toggle.checked = settingsState[widget][key];
                });
                updateLocationSelectors();
                updateMarqueeSelectorUI();
                loadMarqueeSettingsToUI(document.getElementById('marquee-selector').value);
                const teSettings = settingsState.timedEffect;
                if (teSettings) {
                    document.getElementById('timed-effect-enabled-toggle').checked = teSettings.enabled;
                    document.getElementById('timed-effect-interval-seconds').value = teSettings.intervalSeconds;
                    const effectTypeSelect = document.getElementById('timed-effect-type');
                    effectTypeSelect.value = teSettings.type || 'slide';
                    document.getElementById('transition-effect-enabled-toggle').checked = teSettings.transitionEnabled ?? false;

                    const layoutSwitchOptions = document.getElementById('layout-switch-options');
                    const randomToggle = document.getElementById('layout-switch-random-toggle');
                    if (teSettings.type === 'layoutSwitch') {
                        layoutSwitchOptions.style.display = 'flex';
                        randomToggle.checked = teSettings.isRandom ?? false;
                    } else {
                        layoutSwitchOptions.style.display = 'none';
                    }
                }
            }
            const marqueeSelector = document.getElementById('marquee-selector'), marqueeTextInput = document.getElementById('marquee-text-input'), marqueeSpeedInput = document.getElementById('marquee-speed-input'), marqueeVerticalToggle = document.getElementById('marquee-vertical-toggle'), marqueeEnabledToggle = document.getElementById('marquee-enabled-toggle'), marqueeColorInput = document.getElementById('marquee-default-color'), marqueeDirectionSelect = document.getElementById('marquee-direction-select');
            function updateMarqueeSelectorUI() {
                const currentVal = marqueeSelector.value;
                marqueeSelector.innerHTML = '';
                for (let i = 0; i < settingsState.marquees.length; i++) {
                    marqueeSelector.add(new Option(`${i + 1}`, i));
                }
                if (document.querySelector(`#marquee-selector option[value="${currentVal}"]`)) {
                    marqueeSelector.value = currentVal;
                }
                document.getElementById('remove-marquee-btn').disabled = marqueeSelector.value === '0' || settingsState.marquees.length <= 1;
            }
            ['left', 'right', 'up', 'down'].forEach(dir => marqueeDirectionSelect.add(new Option({'left':'左','right':'右','up':'上','down':'下'}[dir], dir)));
            function updateDirectionOptions(isVertical) {
                for (const option of marqueeDirectionSelect.options) {
                    const isVerticalOption = ['up', 'down'].includes(option.value);
                    option.disabled = isVertical ? !isVerticalOption : isVerticalOption;
                }
            }
            function loadMarqueeSettingsToUI(index) {
                const settings = settingsState.marquees[index]; if (!settings) return;
                marqueeTextInput.value = settings.text; marqueeSpeedInput.value = settings.speed;
                marqueeVerticalToggle.checked = settings.vertical; marqueeEnabledToggle.checked = transformStates[`marquee-container-${index}`]?.visible ?? false;
                marqueeDirectionSelect.value = settings.direction || (settings.vertical ? 'up' : 'left');
                marqueeColorInput.value = settings.colors?.default || '#FFFFFF';
                updateDirectionOptions(settings.vertical);
            }
            marqueeSelector.addEventListener('change', (e) => {
                loadMarqueeSettingsToUI(e.target.value);
                document.getElementById('remove-marquee-btn').disabled = e.target.value === '0' || settingsState.marquees.length <= 1;
            });
            function updateMarqueeSettingFromUI() {
                const index = marqueeSelector.value; if (!settingsState.marquees[index]) return;
                const s = settingsState.marquees[index];
                s.text = marqueeTextInput.value; s.speed = marqueeSpeedInput.value; s.vertical = marqueeVerticalToggle.checked;
                s.direction = marqueeDirectionSelect.value;
                if (!s.colors) s.colors = {};
                s.colors['default'] = marqueeColorInput.value;
                MarqueeManager.rebuildAnimationByIndex(index); saveCurrentSettings();
            }
            marqueeVerticalToggle.addEventListener('change', e => { const isVertical = e.target.checked; updateDirectionOptions(isVertical); marqueeDirectionSelect.value = isVertical ? 'up' : 'left'; updateMarqueeSettingFromUI(); });
            marqueeEnabledToggle.addEventListener('change', e => {
                const widgetId = `marquee-container-${marqueeSelector.value}`, isVisible = e.target.checked;
                if (transformStates[widgetId]) {
                    transformStates[widgetId].visible = isVisible;
                    document.getElementById(widgetId).style.display = isVisible ? 'flex' : 'none';
                    const mainToggle = document.querySelector(`input[data-widget-toggle="${widgetId}"]`);
                    if (mainToggle) mainToggle.checked = isVisible;
                    saveCurrentSettings();
                }
            });
            ['input', 'change'].forEach(evt => { ['marquee-text-input', 'marquee-speed-input', 'marquee-default-color', 'marquee-direction-select'].forEach(id => document.getElementById(id).addEventListener(evt, updateMarqueeSettingFromUI)); });
            document.getElementById('settings-btn').addEventListener('click', () => { updateSettingsUIFromState(); showModal('modal-backdrop-settings'); });
            document.querySelector('#modal-backdrop-settings').addEventListener('input', e => {
                if (e.target.dataset.settingType === 'color') {
                    const widget = e.target.dataset.widget, cssVar = e.target.dataset.var, color = e.target.value;
                    document.documentElement.style.setProperty(cssVar, color);
                    if (settingsState[widget]?.colors) settingsState[widget].colors[cssVar] = color;
                    if (widget === 'moonPhase') MoonPhaseWidget.render(); if (widget === 'calendar') Calendar.render(); if (widget === 'analogClock') AnalogClock.init();
                    MarqueeManager.rebuildAllAnimations(); saveCurrentSettings();
                }
            });
            document.querySelector('#modal-backdrop-settings').addEventListener('change', e => {
                const toggle = e.target.closest('input[data-widget-toggle]');
                if (toggle) {
                    const widgetId = toggle.dataset.widgetToggle, widgetEl = document.getElementById(widgetId);
                    if (widgetEl && transformStates[widgetId]) {
                        transformStates[widgetId].visible = toggle.checked; widgetEl.style.display = toggle.checked ? 'flex' : 'none';
                        if (widgetId.startsWith('marquee-container-') && widgetId === `marquee-container-${marqueeSelector.value}`) marqueeEnabledToggle.checked = toggle.checked;
                        saveCurrentSettings();
                    }
                }
                const settingToggle = e.target.closest('input[data-setting-type="toggle"]');
                if (settingToggle) {
                    const widget = settingToggle.dataset.widget, key = settingToggle.dataset.key;
                    if (settingsState[widget]) {
                        settingsState[widget][key] = settingToggle.checked; saveCurrentSettings();
                        if (widget === 'calendar') Calendar.render(); if (widget === 'analogClock') AnalogClock.init(); if (widget === 'moonPhase') MoonPhaseWidget.render(); if (widget === 'marqueeGlobal') MarqueeManager.rebuildAllAnimations();
                    }
                }
            });
            function getRandomHexColor() { return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); }
            function applyRandomColors() { document.querySelectorAll('#modal-backdrop-settings .color-picker').forEach(p => { p.value = getRandomHexColor(); p.dispatchEvent(new Event('input', { bubbles: true })); }); }
            document.getElementById('random-colors-btn').addEventListener('click', applyRandomColors);
            document.getElementById('default-settings-btn').addEventListener('click', applyDefaultSettings);
            // ===================================================================
            // 編輯模式與拖曳縮放
            // 說明: 處理編輯模式下的所有互動，包括拖曳、縮放、還原尺寸等。
            // ===================================================================
            document.getElementById('edit-layout-btn').addEventListener('click', () => {
                isEditMode = !isEditMode;
                const timedEffectToggle = document.getElementById('timed-effect-enabled-toggle');
                const timedEffectInterval = document.getElementById('timed-effect-interval-seconds');
                if (isEditMode) {
                    MarqueeManager.setPlayState(false);
                    timedEffectToggle.disabled = true; timedEffectInterval.disabled = true;
                } else {
                    clearGroupSelection();
                    MarqueeManager.setPlayState(true); saveCurrentSettings();
                    editToolbar.style.left = '50%'; editToolbar.style.top = 'auto'; editToolbar.style.bottom = ''; editToolbar.style.transform = 'translateX(-50%)';
                    timedEffectToggle.disabled = false; timedEffectInterval.disabled = false;
                }
                document.body.classList.toggle('edit-mode', isEditMode);
                allWidgetContainers().forEach(c => c.classList.toggle('edit-mode', isEditMode));
                document.getElementById('edit-icon').classList.toggle('display-none', isEditMode);
                document.getElementById('edit-exit-icon').classList.toggle('display-none', !isEditMode);
                editToolbar.classList.toggle('show', isEditMode);
                document.querySelectorAll('.calendar-day').forEach(d => d.classList.toggle('edit-mode-active', isEditMode));
                resetActivityTimeout();
            });
            let activeHandle = null, startX, startY, initialTransformState, scaleCenterX, scaleCenterY, initialDist, activeWidget;
            const applyTransform = (widgetEl, state) => {
                if (!widgetEl || !state) return;
                const { left, top, width, height, scale, visible, rotation = 0 } = state;
                widgetEl.style.left = `${left}px`; widgetEl.style.top = `${top}px`;
                widgetEl.style.width = `${width}px`; widgetEl.style.height = `${height}px`;
                widgetEl.style.transformOrigin = 'center';
                widgetEl.style.transform = `scale(${scale}) rotate(${rotation}deg)`;
                widgetEl.style.display = visible ? 'flex' : 'none';
                if (widgetEl.classList.contains('calendar-widget') && state.height > 0) {
                    widgetEl.querySelector('.background-month').style.fontSize = `${state.height * 0.7}px`;
                    widgetEl.style.fontSize = `${state.height / 40}px`;
                    const titleElement = widgetEl.querySelector('.calendar-title'), headerContainer = widgetEl.querySelector('.calendar-header'), navElement = widgetEl.querySelector('.calendar-nav');
                    if (titleElement && headerContainer && navElement) {
                        headerContainer.getBoundingClientRect();
                        const availableWidth = headerContainer.clientWidth - navElement.offsetWidth - 16;
                        if (titleElement.scrollWidth > availableWidth && availableWidth > 0) widgetEl.style.fontSize = `${parseFloat(getComputedStyle(widgetEl).fontSize) * (availableWidth / titleElement.scrollWidth)}px`;
                    }
                } else if (widgetEl.id === 'analog-clock-container') {
                    widgetEl.style.fontSize = `${state.width / 20}px`;
                } else if (widgetEl.classList.contains('marquee-widget')) {
                    widgetEl.style.fontSize = `${state.height * 0.75}px`;
                    MarqueeManager.rebuildAnimationByIndex(parseInt(widgetEl.id.split('-')[2]));
                }
                const inverseScale = 1 / scale;
                widgetEl.querySelectorAll('.control-handle, .group-select-handle').forEach(h => {
                     h.style.transform = `scale(${inverseScale})`;
                });
            };
            const applyAllTransforms = () => { Object.keys(transformStates).forEach(id => applyTransform(document.getElementById(id), transformStates[id])); };
            function checkAndClampWidgetBounds(state) {
                if (!state || !state.visible) return;
                const winW = window.innerWidth, winH = window.innerHeight;
                const renderedWidth = state.width * state.scale;
                const renderedHeight = state.height * state.scale;
                const offsetX = (state.width - renderedWidth) / 2;
                const offsetY = (state.height - renderedHeight) / 2;
                const renderedLeft = state.left + offsetX;
                const renderedTop = state.top + offsetY;
                const marginW = renderedWidth * 0.05;
                const marginH = renderedHeight * 0.05;
                const clampedRenderedLeft = Math.max(-marginW, Math.min(renderedLeft, winW - renderedWidth + marginW));
                const clampedRenderedTop = Math.max(-marginH, Math.min(renderedTop, winH - renderedHeight + marginH));
                state.left = clampedRenderedLeft - offsetX;
                state.top = clampedRenderedTop - offsetY;
            }
            const ensureWidgetsInBounds = () => { Object.values(transformStates).forEach(checkAndClampWidgetBounds); applyAllTransforms(); };
            const onDragStart = (e) => {
                if (!isEditMode) return;
                if (e.target.closest('.group-select-handle')) return;

                const targetWidget = e.target.closest('.widget-container');
                const groupRotateHandleEl = e.target.closest('#group-rotate-handle');
                const groupScaleHandleEl = e.target.closest('#group-scale-handle');
                
                let isDragAction = false;
                activeHandle = null;

                if (groupRotateHandleEl) {
                    activeHandle = 'group-rotate'; isDragAction = true;
                } else if (groupScaleHandleEl) {
                    activeHandle = 'group-scale'; isDragAction = true;
                }
                else if (targetWidget) {
                    const individualHandle = e.target.closest('.control-handle');

                    if (individualHandle && !individualHandle.classList.contains('reset-handle')) {
                        if (individualHandle.classList.contains('rotate-handle')) activeHandle = 'rotate';
                        else if (individualHandle.classList.contains('scale-handle')) activeHandle = 'scale';
                        else if (individualHandle.classList.contains('resize-handle-w')) activeHandle = 'resize-w';
                        else if (individualHandle.classList.contains('resize-handle-h')) activeHandle = 'resize-h';
                        if (activeHandle) isDragAction = true;

                    } else if (!individualHandle) {
                        const isPartOfGroup = selectedWidgets.has(targetWidget.id) && selectedWidgets.size >= 2;
                        activeHandle = isPartOfGroup ? 'group-move' : 'move';
                        isDragAction = true;
                    }
                }

                if (!isDragAction || !activeHandle) return;
                
                e.preventDefault(); e.stopPropagation();
                document.body.style.userSelect = 'none';
                startX = (e.touches ? e.touches[0] : e).clientX;
                startY = (e.touches ? e.touches[0] : e).clientY;

                if (activeHandle.startsWith('group')) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    selectedWidgets.forEach(id => {
                        const state = transformStates[id]; if (!state || !state.visible) return;
                        const renderedWidth = state.width * state.scale, renderedHeight = state.height * state.scale;
                        const offsetX = (state.width - renderedWidth) / 2, offsetY = (state.height - renderedHeight) / 2;
                        const renderedLeft = state.left + offsetX, renderedTop = state.top + offsetY;
                        minX = Math.min(minX, renderedLeft); minY = Math.min(minY, renderedTop);
                        maxX = Math.max(maxX, renderedLeft + renderedWidth); maxY = Math.max(maxY, renderedTop + renderedHeight);
                    });
                    scaleCenterX = minX + (maxX - minX) / 2; scaleCenterY = minY + (maxY - minY) / 2;
                    initialGroupTransforms = {};
                    selectedWidgets.forEach(id => { initialGroupTransforms[id] = { ...transformStates[id] }; });
                    if (activeHandle === 'group-scale') {
                        initialDist = Math.hypot(startX - scaleCenterX, startY - scaleCenterY);
                    } else if (activeHandle === 'group-rotate') {
                        initialGroupTransforms.startAngle = Math.atan2(startY - scaleCenterY, startX - scaleCenterX);
                        if (groupRotateHandle) { initialGroupTransforms.rotateHandle = { left: groupRotateHandle.offsetLeft, top: groupRotateHandle.offsetTop }; }
                        if (groupScaleHandle) { initialGroupTransforms.scaleHandle = { left: groupScaleHandle.offsetLeft, top: groupScaleHandle.offsetTop }; }
                    }
                } 
                else {
                    allWidgetContainers().forEach(w => w.style.zIndex = '10');
                    targetWidget.style.zIndex = '100';
                    const originalTransition = targetWidget.style.transition;
                    targetWidget.style.transition = 'none';
                    activeWidget = { el: targetWidget, state: transformStates[targetWidget.id], originalTransition: originalTransition };
                    
                    const isPartOfGroup = selectedWidgets.has(targetWidget.id) && selectedWidgets.size >= 2;

                    if (isPartOfGroup && (activeHandle === 'rotate' || activeHandle === 'scale')) {
                        initialGroupTransforms = {};
                        selectedWidgets.forEach(id => { initialGroupTransforms[id] = { ...transformStates[id] }; });
                    } else {
                        initialTransformState = { ...activeWidget.state };
                    }
                    
                    if (activeHandle === 'scale' || activeHandle === 'rotate') {
                        const rect = activeWidget.el.getBoundingClientRect();
                        scaleCenterX = rect.left + rect.width / 2; scaleCenterY = rect.top + rect.height / 2;
                        if (activeHandle === 'scale') {
                            initialDist = Math.hypot(startX - scaleCenterX, startY - scaleCenterY);
                        } else { // 'rotate'
                            const startAngle = Math.atan2(startY - scaleCenterY, startX - scaleCenterX) * (180 / Math.PI);
                            if (isPartOfGroup) {
                                initialGroupTransforms.startAngle = startAngle;
                            } else {
                                initialTransformState.startAngle = startAngle;
                            }
                        }
                    }
                }

                window.addEventListener('mousemove', onDragMove); 
                window.addEventListener('touchmove', onDragMove, { passive: false });
                window.addEventListener('mouseup', onDragEnd); 
                window.addEventListener('touchend', onDragEnd);
            };
            const onDragMove = (e) => {
                if (!activeHandle) return;
                const currentX = (e.touches ? e.touches[0] : e).clientX, currentY = (e.touches ? e.touches[0] : e).clientY;
                const dx = currentX - startX, dy = currentY - startY;
                
                if (activeHandle === 'group-move') {
                    document.body.style.cursor = 'grabbing';
                    selectedWidgets.forEach(id => {
                        const widgetEl = document.getElementById(id); const initialState = initialGroupTransforms[id]; const state = transformStates[id];
                        state.left = initialState.left + dx; state.top = initialState.top + dy;
                        applyTransform(widgetEl, state);
                    });
                    if (groupRotateHandle) groupRotateHandle.style.transform = `translate(${dx}px, ${dy}px)`;
                    if (groupScaleHandle) groupScaleHandle.style.transform = `translate(${dx}px, ${dy}px)`;
                    return;
                }
                if (activeHandle === 'group-scale') {
                    const currentDist = Math.hypot(currentX - scaleCenterX, currentY - scaleCenterY);
                    const scaleFactor = initialDist > 0 ? (currentDist / initialDist) : 1;
                    selectedWidgets.forEach(id => {
                        const widgetEl = document.getElementById(id);
                        const initialState = initialGroupTransforms[id];
                        const state = transformStates[id];
                        let newScale = initialState.scale * scaleFactor;
                        state.scale = Math.max(0.1, Math.min(newScale, 10));
                        const initialWidgetLayoutCenterX = initialState.left + initialState.width / 2;
                        const initialWidgetLayoutCenterY = initialState.top + initialState.height / 2;
                        const newWidgetLayoutCenterX = scaleCenterX + (initialWidgetLayoutCenterX - scaleCenterX) * scaleFactor;
                        const newWidgetLayoutCenterY = scaleCenterY + (initialWidgetLayoutCenterY - scaleCenterY) * scaleFactor;
                        state.left = newWidgetLayoutCenterX - state.width / 2;
                        state.top = newWidgetLayoutCenterY - state.height / 2;
                        applyTransform(widgetEl, state);
                    });
                    document.body.style.cursor = 'se-resize';
                    updateGroupControls();
                    return;
                }
                if (activeHandle === 'group-rotate') {
                    document.body.style.cursor = 'alias';
                    const currentAngle = Math.atan2(currentY - scaleCenterY, currentX - scaleCenterX);
                    const angleDelta = currentAngle - initialGroupTransforms.startAngle;
                    const cosA = Math.cos(angleDelta); const sinA = Math.sin(angleDelta);
                    selectedWidgets.forEach(id => {
                        const widgetEl = document.getElementById(id);
                        const initialState = initialGroupTransforms[id];
                        const state = transformStates[id];
                        const initialWidgetCenterX = initialState.left + (initialState.width / 2);
                        const initialWidgetCenterY = initialState.top + (initialState.height / 2);
                        const vecX = initialWidgetCenterX - scaleCenterX;
                        const vecY = initialWidgetCenterY - scaleCenterY;
                        const rotatedVecX = vecX * cosA - vecY * sinA;
                        const rotatedVecY = vecX * sinA + vecY * cosA;
                        state.left = (scaleCenterX + rotatedVecX) - (state.width / 2);
                        state.top = (scaleCenterY + rotatedVecY) - (state.height / 2);
                        state.rotation = (initialState.rotation || 0) + (angleDelta * 180 / Math.PI);
                        applyTransform(widgetEl, state);
                    });
                    const rotateHandle = (handle, initialPos) => {
                        if (!handle || !initialPos) return;
                        const initialHandleCenterX = initialPos.left + handle.offsetWidth / 2;
                        const initialHandleCenterY = initialPos.top + handle.offsetHeight / 2;
                        const vecX = initialHandleCenterX - scaleCenterX;
                        const vecY = initialHandleCenterY - scaleCenterY;
                        const rotatedVecX = vecX * cosA - vecY * sinA;
                        const rotatedVecY = vecX * sinA + vecY * cosA;
                        handle.style.left = `${(scaleCenterX + rotatedVecX) - handle.offsetWidth / 2}px`;
                        handle.style.top = `${(scaleCenterY + rotatedVecY) - handle.offsetHeight / 2}px`;
                    };
                    rotateHandle(groupRotateHandle, initialGroupTransforms.rotateHandle);
                    rotateHandle(groupScaleHandle, initialGroupTransforms.scaleHandle);
                    return;
                }
                
                if (!activeWidget) return; e.preventDefault();
                const isGroupSyncAction = selectedWidgets.has(activeWidget.el.id) && selectedWidgets.size >= 2;

                switch (activeHandle) {
                    case 'move': 
                        document.body.style.cursor = 'grabbing'; 
                        activeWidget.state.left = initialTransformState.left + dx; 
                        activeWidget.state.top = initialTransformState.top + dy;
                        checkAndClampWidgetBounds(activeWidget.state);
                        applyTransform(activeWidget.el, activeWidget.state);
                        break;
                    case 'resize-w': {
                        document.body.style.cursor = 'ew-resize';
                        const newWidth = Math.max(50, initialTransformState.width + dx);
                        activeWidget.state.width = newWidth;
                        if (activeWidget.el.id === 'analog-clock-container') {
                            activeWidget.state.height = newWidth;
                        } else if (activeWidget.el.id === 'led-clock-container' && LedClock.aspectRatio > 0) {
                            activeWidget.state.height = newWidth / LedClock.aspectRatio;
                        }
                        checkAndClampWidgetBounds(activeWidget.state);
                        applyTransform(activeWidget.el, activeWidget.state);
                        break;
                    }
                    case 'resize-h': {
                        document.body.style.cursor = 'ns-resize';
                        const newHeight = Math.max(50, initialTransformState.height + dy);
                        activeWidget.state.height = newHeight;
                        if (activeWidget.el.id === 'analog-clock-container') {
                             activeWidget.state.width = newHeight;
                        } else if (activeWidget.el.id === 'led-clock-container' && LedClock.aspectRatio > 0) {
                            activeWidget.state.width = newHeight * LedClock.aspectRatio;
                        }
                        checkAndClampWidgetBounds(activeWidget.state);
                        applyTransform(activeWidget.el, activeWidget.state);
                        break;
                    }
                    case 'scale': {
                        document.body.style.cursor = 'se-resize';
                        const currentDist = Math.hypot(currentX - scaleCenterX, currentY - scaleCenterY);
                        const scaleFactor = initialDist > 0 ? (currentDist / initialDist) : 1;

                        if (isGroupSyncAction) {
                            selectedWidgets.forEach(id => {
                                const widgetEl = document.getElementById(id);
                                const initialState = initialGroupTransforms[id];
                                const state = transformStates[id];
                                let newScale = initialState.scale * scaleFactor;
                                state.scale = Math.max(0.2, Math.min(newScale, 5));
                                applyTransform(widgetEl, state);
                            });
                        } else {
                            let newScale = initialTransformState.scale * scaleFactor;
                            activeWidget.state.scale = Math.max(0.2, Math.min(newScale, 5));
                            checkAndClampWidgetBounds(activeWidget.state);
                            applyTransform(activeWidget.el, activeWidget.state);
                        }
                        break;
                    }
                    case 'rotate':
                        document.body.style.cursor = 'alias';
                        const angle = Math.atan2(currentY - scaleCenterY, currentX - scaleCenterX) * (180 / Math.PI);
                        if (isGroupSyncAction) {
                            const rotationDelta = angle - initialGroupTransforms.startAngle;
                            selectedWidgets.forEach(id => {
                                const widgetEl = document.getElementById(id);
                                const initialState = initialGroupTransforms[id];
                                const state = transformStates[id];
                                state.rotation = (initialState.rotation || 0) + rotationDelta;
                                applyTransform(widgetEl, state);
                            });
                        } else {
                            const rotationDelta = angle - initialTransformState.startAngle;
                            activeWidget.state.rotation = (initialTransformState.rotation || 0) + rotationDelta;
                            checkAndClampWidgetBounds(activeWidget.state);
                            applyTransform(activeWidget.el, activeWidget.state);
                        }
                        break;
                }
            };
            const onDragEnd = () => {
                if (!activeHandle) return;
                if (activeHandle.startsWith('group')) {
                    if (groupMoveHandle) groupMoveHandle.style.transform = '';
                    if (groupRotateHandle) groupRotateHandle.style.transform = '';
                    if (groupScaleHandle) groupScaleHandle.style.transform = '';
                    selectedWidgets.forEach(id => checkAndClampWidgetBounds(transformStates[id]));
                    applyAllTransforms();
                    updateGroupControls();
                } else if (activeWidget?.el) {
                    activeWidget.el.style.transition = activeWidget.originalTransition;
                    ensureWidgetsInBounds();
                }
                document.body.style.cursor = 'default'; document.body.style.userSelect = 'auto'; activeHandle = null; activeWidget = null;
                window.removeEventListener('mousemove', onDragMove); window.removeEventListener('touchmove', onDragMove);
                window.removeEventListener('mouseup', onDragEnd); window.removeEventListener('touchend', onDragEnd);
                saveCurrentSettings();
            };
            document.body.addEventListener('mousedown', onDragStart); document.body.addEventListener('touchstart', onDragStart, { passive: false });
            // ===================================================================
            // 群組功能相關函式
            // ===================================================================
            function toggleWidgetSelection(widgetEl) {
                const widgetId = widgetEl.id, uncheckedIcon = widgetEl.querySelector('.group-select-handle .unchecked'), checkedIcon = widgetEl.querySelector('.group-select-handle .checked');
                if (selectedWidgets.has(widgetId)) {
                    selectedWidgets.delete(widgetId); widgetEl.classList.remove('selected-for-group');
                    uncheckedIcon.style.display = 'block'; checkedIcon.style.display = 'none';
                } else {
                    selectedWidgets.add(widgetId); widgetEl.classList.add('selected-for-group');
                    uncheckedIcon.style.display = 'none'; checkedIcon.style.display = 'block';
                }
                updateGroupControls();
            }
            function updateGroupControls() {
                if (selectedWidgets.size < 2) {
                    // if (groupMoveHandle) { groupMoveHandle.remove(); groupMoveHandle = null; }
                    if (groupRotateHandle) { groupRotateHandle.remove(); groupRotateHandle = null; }
                    if (groupScaleHandle) { groupScaleHandle.remove(); groupScaleHandle = null; }
                    return;
                }
                
                // 計算群組的整體邊界 (minX, minY, maxX, maxY)
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                selectedWidgets.forEach(id => {
                    const state = transformStates[id]; if (!state || !state.visible) return;
                    const renderedWidth = state.width * state.scale, renderedHeight = state.height * state.scale;
                    const offsetX = (state.width - renderedWidth) / 2, offsetY = (state.height - renderedHeight) / 2;
                    const renderedLeft = state.left + offsetX, renderedTop = state.top + offsetY;
                    minX = Math.min(minX, renderedLeft); minY = Math.min(minY, renderedTop);
                    maxX = Math.max(maxX, renderedLeft + renderedWidth); maxY = Math.max(maxY, renderedTop + renderedHeight);
                });
                
                if (!isFinite(minX)) return;
                
                if (groupMoveHandle) { groupMoveHandle.remove(); groupMoveHandle = null; }

                // 建立或更新右下角的旋轉圖示
                 if (!groupRotateHandle) {
                    groupRotateHandle = document.createElement('div');
                    groupRotateHandle.id = 'group-rotate-handle';
                    groupRotateHandle.innerHTML = `<svg class="width-full height-full" viewBox="0 0 24 24"><use href="#icon-rotate" stroke="black" stroke-width="1.5"></use></svg>`;
                    document.body.appendChild(groupRotateHandle);
                }
                
                if (!groupScaleHandle) {
                    groupScaleHandle = document.createElement('div');
                    groupScaleHandle.id = 'group-scale-handle';
                    groupScaleHandle.innerHTML = `<svg class="width-full height-full" viewBox="0 0 24 24"><use href="#icon-scale" stroke="black" stroke-width="1.5"></use></svg>`;
                    document.body.appendChild(groupScaleHandle);
                }
                
                // 根據群組邊界定位控制圖示
                groupRotateHandle.style.left = `${maxX - groupRotateHandle.offsetWidth / 2}px`;
                groupRotateHandle.style.top = `${maxY - groupRotateHandle.offsetHeight / 2}px`;
                groupScaleHandle.style.left = `${minX - groupScaleHandle.offsetWidth / 2}px`;
                groupScaleHandle.style.top = `${maxY - groupScaleHandle.offsetHeight / 2}px`;

            }
           function clearGroupSelection() {
                // if (groupMoveHandle) { groupMoveHandle.remove(); groupMoveHandle = null; }
                if (groupRotateHandle) { groupRotateHandle.remove(); groupRotateHandle = null; }
                if (groupScaleHandle) { groupScaleHandle.remove(); groupScaleHandle = null; }
                
                // 清除所有被選取元件的樣式與狀態
                selectedWidgets.forEach(id => {
                    const widgetEl = document.getElementById(id); if (!widgetEl) return;
                    widgetEl.classList.remove('selected-for-group');
                    const uncheckedIcon = widgetEl.querySelector('.group-select-handle .unchecked'), checkedIcon = widgetEl.querySelector('.group-select-handle .checked');
                    if (uncheckedIcon) uncheckedIcon.style.display = 'block';
                    if (checkedIcon) checkedIcon.style.display = 'none';
                });
                selectedWidgets.clear();

            }
            // ===================================================================
            // 版面配置儲存/載入
            // ===================================================================
            const getCurrentLayout = () => {
                const settingsToSave = JSON.parse(JSON.stringify(settingsState));
                delete settingsToSave.timedEffect; // 不要儲存定時特效設定
                delete settingsToSave.location; // 不要儲存地區設定
                return {
                    transforms: JSON.parse(JSON.stringify(transformStates)),
                    settings: settingsToSave
                };
            };
            const applyLayout = (layout, options = {}) => {
                const layoutToApply = JSON.parse(JSON.stringify(layout));
                const { ignoreTimedEffect = false, ignoreLocation = false } = options;
                if (layoutToApply.transforms) transformStates = { ...transformStates, ...layoutToApply.transforms };
                if (layoutToApply.settings) {
                    Object.keys(layoutToApply.settings).forEach(key => {
                        if (ignoreTimedEffect && key === 'timedEffect') return;
                        if (ignoreLocation && key === 'location') return;
                        if (key === 'marquees' && Array.isArray(layoutToApply.settings[key])) {
                            settingsState[key] = layoutToApply.settings[key].map(m => (typeof m.color === 'string' && !m.colors) ? { ...m, colors: { default: m.color }, color: undefined } : m);
                        } else if (typeof layoutToApply.settings[key] === 'object' && !Array.isArray(layoutToApply.settings[key]) && layoutToApply.settings[key] !== null) {
                            settingsState[key] = { ...(settingsState[key] || {}), ...layoutToApply.settings[key] };
                        } else {
                            settingsState[key] = layoutToApply.settings[key];
                        }
                    });
                }
                syncMarqueeDOMElements();
                MarqueeManager.syncInstances();
                applyAllSettings();
            };
            function animateLayoutChange(targetLayout, duration = 1000, preserveTimedEffectSettings = false, callback = null) {
                if (!targetLayout || !targetLayout.transforms || Object.values(isWidgetAnimating).some(v => v)) return;
                const sourceTransforms = transformStates;
                const targetTransforms = targetLayout.transforms;
                const allWidgetIds = new Set([...Object.keys(sourceTransforms), ...Object.keys(targetTransforms)]);
                const transitionStyle = `transform ${duration}ms cubic-bezier(0.4, 0, 0.2, 1), opacity ${duration}ms cubic-bezier(0.4, 0, 0.2, 1), width ${duration}ms cubic-bezier(0.4, 0, 0.2, 1), height ${duration}ms cubic-bezier(0.4, 0, 0.2, 1), left ${duration}ms cubic-bezier(0.4, 0, 0.2, 1), top ${duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;

                allWidgetIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    el.style.willChange = 'transform, opacity';
                    el.style.transform += ' translateZ(0)';

                    const sourceState = sourceTransforms[id];
                    const targetState = targetTransforms[id];
                    const isVisibleSource = sourceState?.visible ?? false;
                    const isVisibleTarget = targetState?.visible ?? false;
                    isWidgetAnimating[id] = true;
                    if (isVisibleSource && !isVisibleTarget) {
                        el.style.transition = transitionStyle;
                        const newTransform = `scale(0) rotate(${sourceState.rotation || 0}deg)`;
                        el.style.transform = newTransform;
                        el.style.opacity = '0';
                    } else if (!isVisibleSource && isVisibleTarget) {
                        el.style.transition = 'none';
                        el.style.opacity = '0';
                        applyTransform(el, { ...targetState, scale: 0 });
                        el.style.display = 'flex';
                        void el.offsetWidth;
                        el.style.transition = transitionStyle;
                        el.style.opacity = '1';
                        applyTransform(el, targetState);
                    } else if (isVisibleSource && isVisibleTarget) {
                        el.style.transition = transitionStyle;
                        applyTransform(el, targetState);
                    }
                });
                setTimeout(() => {
                    applyLayout(targetLayout, { ignoreTimedEffect: preserveTimedEffectSettings, ignoreLocation: true });
                    
                    if (callback) {
                        callback();
                    } else {
                        saveCurrentSettings(true);
                    }
                    
                    allWidgetIds.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                             el.style.transition = '';
                             el.style.willChange = 'auto';
                             applyTransform(el, transformStates[id]);
                        }
                        isWidgetAnimating[id] = false;
                    });
                }, duration + 100);
            }
            const toolbarTitle = document.getElementById('toolbar-title');
            let toolbarMoving = false, toolbarOffsetX, toolbarOffsetY;
            const handleToolbarDragStart = (e) => { e.preventDefault(); toolbarMoving = true; const rect = editToolbar.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; toolbarOffsetX = clientX - rect.left; toolbarOffsetY = clientY - rect.top; editToolbar.style.transition = 'none'; };
            const handleToolbarDragMove = (e) => { if (!toolbarMoving) return; const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; let x = clientX - toolbarOffsetX, y = clientY - toolbarOffsetY; const rect = editToolbar.getBoundingClientRect(); x = Math.max(0, Math.min(x, window.innerWidth - rect.width)); y = Math.max(0, Math.min(y, window.innerHeight - rect.height)); editToolbar.style.left = `${x}px`; editToolbar.style.top = `${y}px`; editToolbar.style.bottom = 'auto'; editToolbar.style.transform = 'none'; };
            const handleToolbarDragEnd = () => { if (toolbarMoving) { toolbarMoving = false; editToolbar.style.transition = 'bottom 0.3s ease-in-out'; } };
            toolbarTitle.addEventListener('mousedown', handleToolbarDragStart); toolbarTitle.addEventListener('touchstart', handleToolbarDragStart, { passive: false });
            document.addEventListener('mousemove', handleToolbarDragMove); document.addEventListener('touchmove', handleToolbarDragMove, { passive: false });
            document.addEventListener('mouseup', handleToolbarDragEnd); document.addEventListener('touchend', handleToolbarDragEnd);
            const layoutSelector = document.getElementById('layout-selector');
            function updateLayoutSelector() {
                const currentVal = layoutSelector.value;
                layoutSelector.innerHTML = '';
                if (layouts.length === 0) {
                    layoutSelector.add(new Option('(無存檔)', -1));
                    layoutSelector.disabled = true;
                } else {
                    layouts.forEach((layout, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${index + 1}. ${layout.name || '(未命名)'}`;
                        layoutSelector.appendChild(option);
                    });
                    layoutSelector.disabled = false;
                }
                if (layoutSelector.querySelector(`option[value="${currentVal}"]`)) {
                    layoutSelector.value = currentVal;
                }
                document.getElementById('delete-layout-btn').disabled = layouts.length === 0;
                document.getElementById('load-layout-btn').disabled = layouts.length === 0;
                document.getElementById('export-layout-btn').disabled = layouts.length === 0;
                const effectTypeSelect = document.getElementById('timed-effect-type');
                const switchLayoutOption = effectTypeSelect.querySelector('option[value="layoutSwitch"]');
                if (switchLayoutOption) {
                    if (layouts.length < 2) {
                        switchLayoutOption.disabled = true;
                        switchLayoutOption.textContent = '版面切換 (需2組以上)';
                        if (effectTypeSelect.value === 'layoutSwitch') {
                            effectTypeSelect.value = 'slide';
                            if (settingsState.timedEffect) { settingsState.timedEffect.type = 'slide'; saveCurrentSettings(); }
                        }
                    } else {
                        switchLayoutOption.disabled = false;
                        switchLayoutOption.textContent = '版面切換';
                    }
                }
            }
            document.getElementById('save-layout-btn').addEventListener('click', () => {
                const defaultName = `版面 ${new Date().toLocaleString('sv').replace(' ', '_')}`;
                showPrompt("新增版面存檔", "請輸入備註:", defaultName, (name) => {
                    if (name === null || name.trim() === '') return;
                    const layout = getCurrentLayout();
                    layout.name = name.trim();
                    layouts.push(layout);
                    localStorage.setItem(STORAGE_LAYOUTS_KEY, JSON.stringify(layouts));
                    updateLayoutSelector();
                    const newIndex = layouts.length - 1;
                    layoutSelector.value = newIndex;
                    currentLayoutIndex = newIndex; // 將目前狀態對應到新的存檔
                });
            });
            document.getElementById('delete-layout-btn').addEventListener('click', () => {
                const index = parseInt(layoutSelector.value, 10);
                if (index < 0 || index >= layouts.length) return;
                const layoutName = layouts[index].name;
                showConfirm("確認刪除", `您確定要刪除存檔 "${layoutName}" 嗎？`, (confirmed) => {
                    if (confirmed) {
                        layouts.splice(index, 1);
                        localStorage.setItem(STORAGE_LAYOUTS_KEY, JSON.stringify(layouts));
                        updateLayoutSelector();
                        nextLayoutIndex = 0; // 重設循序索引
                        showAlert("成功", `存檔 "${layoutName}" 已被刪除。`);
                    }
                });
            });
            document.getElementById('load-layout-btn').addEventListener('click', () => {
                const index = parseInt(layoutSelector.value, 10);
                if (index >= 0 && layouts[index]) {
                    const layoutToLoad = layouts[index];
                    const useTransition = settingsState.timedEffect?.transitionEnabled ?? false;

                    const afterLoadCallback = () => {
                        currentLayoutIndex = -1;
                        saveCurrentSettings();
                        layoutSelector.value = index;
                    };

                    if (useTransition) {
                        animateLayoutChange(layoutToLoad, 1000, true, afterLoadCallback);
                    } else {
                        applyLayout(layoutToLoad, { ignoreTimedEffect: true, ignoreLocation: true });
                        afterLoadCallback();
                    }
                } else {
                    showAlert('提示', '此欄位沒有儲存設定。');
                }
            });
            document.getElementById('export-layout-btn').addEventListener('click', () => {
                if (layouts.length === 0) return showAlert("提示", "沒有可導出的設定！");
                try {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(new Blob([JSON.stringify(layouts, null, 2)], { type: 'application/json' }));
                    a.download = `widgets_settings_${new Date().toISOString().slice(0, 10)}.json`;
                    a.click();
                    URL.revokeObjectURL(a.href);
                } catch (error) {
                    showAlert("錯誤", "導出設定時發生錯誤。");
                }
            });
            document.getElementById('import-layout-btn').addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = e => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = e => {
                        try {
                            const importedLayouts = JSON.parse(e.target.result);
                            if (!Array.isArray(importedLayouts)) throw new Error('檔案格式無效');
                            const validLayouts = importedLayouts.filter(l => l && l.name && l.transforms && l.settings);
                            if (validLayouts.length === 0) throw new Error('檔案中未找到有效的版面設定');
                            showConfirm('導入設定', `此檔案包含 ${validLayouts.length} 組設定。確定要導入並覆蓋所有現有存檔嗎？`, (confirmed) => {
                               if (confirmed) {
                                   layouts = validLayouts;
                                   localStorage.setItem(STORAGE_LAYOUTS_KEY, JSON.stringify(layouts));
                                   updateLayoutSelector();
                                   showAlert("成功", `已成功導入 ${layouts.length} 組設定！`);
                               }
                            });
                        } catch (err) {
                            showAlert('錯誤', '導入失敗，檔案格式錯誤或內容無效！');
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            });
            // ===================================================================
            // 地區選擇器
            // ===================================================================
            const countySelect = document.getElementById('countySelect'), districtSelect = document.getElementById('districtSelect'), manualLocationInput = document.getElementById('manualLocationInput');
            Object.keys(taiwanLocations).forEach(county => countySelect.add(new Option(county, county)));
            function updateDistrictOptions() { districtSelect.innerHTML = ''; const districts = taiwanLocations[countySelect.value]?.districts || {}; Object.keys(districts).forEach(dist => districtSelect.add(new Option(dist, dist))); }
            function updateLocationSelectors() { const loc = settingsState.location; manualLocationInput.value = loc; for (const county in taiwanLocations) { for (const district in taiwanLocations[county].districts) { if (taiwanLocations[county].districts[district].toLowerCase() === loc.toLowerCase()) { countySelect.value = county; updateDistrictOptions(); districtSelect.value = district; return; } } } countySelect.selectedIndex = 0; updateDistrictOptions(); }
            function handleLocationChange(newLocation) { settingsState.location = newLocation; manualLocationInput.value = newLocation; Weather.updateWeather(); saveCurrentSettings(); }
            countySelect.addEventListener('change', () => { updateDistrictOptions(); handleLocationChange(taiwanLocations[countySelect.value].districts[districtSelect.value]); });
            districtSelect.addEventListener('change', () => handleLocationChange(taiwanLocations[countySelect.value].districts[districtSelect.value]));
            manualLocationInput.addEventListener('change', () => handleLocationChange(manualLocationInput.value.trim()));
            document.getElementById('useCurrentLocationBtn').addEventListener('click', () => { if (navigator.geolocation) navigator.geolocation.getCurrentPosition(pos => { fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${pos.coords.latitude}&longitude=${pos.coords.longitude}&localityLanguage=en`).then(r=>r.json()).then(geo=>{const city=geo.locality||geo.city;if(city){handleLocationChange(city);updateLocationSelectors()}}) }); });
            // ===================================================================
            // 天氣模組
            // ===================================================================
            const Weather = {
                data: null,
                init() {
                    setInterval(() => this.updateWeather(), 3 * 60 * 60 * 1000); 
                },
                async fetchAPI(url) { try { const response = await fetch(url); if (!response.ok) throw new Error('API請求失敗'); return await response.json(); } catch (error) { console.error(`獲取資料失敗: ${url}`, error); return null; } },
                async fetchCoordinates(name) { const data = await this.fetchAPI(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(name)}&count=1&language=en&format=json`); return data?.results?.[0] || null; },
                async fetchWeather(lat, lon) { const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code&daily=weather_code,sunrise,sunset&timezone=auto`; return await this.fetchAPI(url); },
                async updateWeather() {
                    const locationName = settingsState.location?.trim();
                    
                    if (!locationName) {
                        this.data = null;
                    } else {
                        const coords = await this.fetchCoordinates(locationName);
                        this.data = coords ? await this.fetchWeather(coords.latitude, coords.longitude) : null;
                    }
                    weatherDataLoaded = true;

                    MarqueeManager._weatherDataChanged = true;
                    MarqueeManager._updateCacheAndGetStatus();
                    MarqueeManager.rebuildAllAnimations();
                },
                getWeatherDescription(code) { const map={0:"晴",1:"多雲時晴",2:"局部多雲",3:"陰",45:"霧",48:"凍霧",51:"毛毛雨",53:"毛毛雨",55:"毛毛雨",56:"凍毛毛雨",57:"凍毛毛雨",61:"雨",63:"雨",65:"大雨",66:"凍雨",67:"凍雨",71:"雪",73:"雪",75:"大雪",77:"冰雹",80:"陣雨",81:"陣雨",82:"大陣雨",85:"陣雪",86:"大陣雪",95:"雷陣雨",96:"雷陣雨伴冰雹",99:"雷陣雨伴冰雹"}; return map[code] || "未知"; },
                getChineseLocationName(englishName) {
                    if (!englishName) return '';
                    for (const county in taiwanLocations) {
                        if (taiwanLocations[county].english.toLowerCase() === englishName.toLowerCase()) return county;
                        for (const district in taiwanLocations[county].districts) { if (taiwanLocations[county].districts[district].toLowerCase() === englishName.toLowerCase()) return district === county ? county : `${county}${district}`; }
                    }
                    return englishName.charAt(0).toUpperCase() + englishName.slice(1);
                }
            };
            // ===================================================================
            // 定時特效設定
            // ===================================================================
            function setupTimedEffectControls() {
                const effectEnabled = document.getElementById('timed-effect-enabled-toggle');
                const effectInterval = document.getElementById('timed-effect-interval-seconds');
                const effectType = document.getElementById('timed-effect-type');
                const layoutSwitchOptions = document.getElementById('layout-switch-options');
                const randomToggle = document.getElementById('layout-switch-random-toggle');
                const transitionEnabledToggle = document.getElementById('transition-effect-enabled-toggle');

                [10, 15, 20, 30, 60].forEach(val => effectInterval.add(new Option(String(val), val)));

                const updateSetting = () => {
                    if (!settingsState.timedEffect) settingsState.timedEffect = JSON.parse(JSON.stringify(userDefaultLayout.settings.timedEffect));
                    settingsState.timedEffect.enabled = effectEnabled.checked;
                    settingsState.timedEffect.intervalSeconds = parseInt(effectInterval.value, 10);
                    settingsState.timedEffect.type = effectType.value;
                    settingsState.timedEffect.isRandom = randomToggle.checked;
                    settingsState.timedEffect.transitionEnabled = transitionEnabledToggle.checked;
                    saveCurrentSettings();
                };

                effectType.addEventListener('change', () => {
                    layoutSwitchOptions.style.display = (effectType.value === 'layoutSwitch') ? 'flex' : 'none';
                    updateSetting();
                });

                effectEnabled.addEventListener('change', updateSetting);
                effectInterval.addEventListener('change', updateSetting);
                randomToggle.addEventListener('change', updateSetting);
                transitionEnabledToggle.addEventListener('change', updateSetting);
            }
            // ===================================================================
            // 動態跑馬燈相關函式
            // ===================================================================
            function createMarqueeElement(index) {
                const template = document.getElementById('marquee-container-0');
                if (!template) { console.error("跑馬燈模板 'marquee-container-0' 找不到!"); return null; }
                const newMarquee = template.cloneNode(true);
                newMarquee.id = `marquee-container-${index}`;
                newMarquee.style.display = 'none';
                document.body.appendChild(newMarquee);
                return newMarquee;
            }
            function syncMarqueeDOMElements() {
                const desiredCount = settingsState.marquees.length;
                const existingWidgets = document.querySelectorAll('.marquee-widget');
                let currentCount = existingWidgets.length;
                while (currentCount < desiredCount) { createMarqueeElement(currentCount); currentCount++; }
                if (currentCount > desiredCount) { for (let i = desiredCount; i < currentCount; i++) { const elToRemove = document.getElementById(`marquee-container-${i}`); if (elToRemove) elToRemove.remove(); } }
            }
            document.getElementById('add-marquee-btn').addEventListener('click', () => {
                const selectedIndex = parseInt(marqueeSelector.value, 10) || 0;
                const newIndex = settingsState.marquees.length;
                const sourceSettings = settingsState.marquees[selectedIndex];
                const sourceTransform = transformStates[`marquee-container-${selectedIndex}`];
                const newSettings = JSON.parse(JSON.stringify(sourceSettings));
                const newTransform = JSON.parse(JSON.stringify(sourceTransform));
                newTransform.top += (sourceTransform.height * sourceTransform.scale) + 10;
                newTransform.visible = true;
                settingsState.marquees.push(newSettings);
                transformStates[`marquee-container-${newIndex}`] = newTransform;
                const newElement = createMarqueeElement(newIndex);
                MarqueeManager.syncInstances();
                updateMarqueeSelectorUI();
                marqueeSelector.value = newIndex;
                loadMarqueeSettingsToUI(newIndex);
                applyTransform(newElement, newTransform);
                MarqueeManager.rebuildAnimationByIndex(newIndex);
                saveCurrentSettings();
                showAlert('成功', `已新增跑馬燈組別 ${newIndex + 1}。`);
            });
            document.getElementById('remove-marquee-btn').addEventListener('click', () => {
                const selectedIndex = parseInt(marqueeSelector.value, 10);
                if (selectedIndex === 0 || settingsState.marquees.length <= 1) { showAlert('提示', '無法刪除預設的跑馬燈組別。'); return; }
                settingsState.marquees.splice(selectedIndex, 1);
                for (let i = selectedIndex; i < settingsState.marquees.length; i++) { transformStates[`marquee-container-${i}`] = transformStates[`marquee-container-${i + 1}`]; }
                delete transformStates[`marquee-container-${settingsState.marquees.length}`];
                syncMarqueeDOMElements();
                document.querySelectorAll('.marquee-widget').forEach((el, i) => { el.id = `marquee-container-${i}`; });
                MarqueeManager.syncInstances();
                MarqueeManager.rebuildAllAnimations();
                const newIndex = Math.max(0, selectedIndex - 1);
                marqueeSelector.value = newIndex;
                updateMarqueeSelectorUI();
                marqueeSelector.value = newIndex;
                loadMarqueeSettingsToUI(newIndex);
                saveCurrentSettings();
                showAlert('成功', `已刪除跑馬燈組別 ${selectedIndex + 1}。`);
            });
            // --- 農曆轉換核心演算法 ---
            function getLunarYearDays(y){let i,sum=348;for(i=0x8000;i>0x8;i>>=1)sum+=(lunarInfo[y-1900]&i)?1:0;return sum+getLunarLeapDays(y)}
            function getLunarLeapMonth(y){return lunarInfo[y-1900]&0xf}
            function getLunarLeapDays(y){return getLunarLeapMonth(y)?((lunarInfo[y-1900]&0x10000)?30:29):0}
            function getLunarMonthDays(y,m){return(lunarInfo[y-1900]&(0x10000>>m))?30:29}
            function toChinaDate(d) {
                if (d < 1 || d > 30) return "";
                const n1 = "一二三四五六七八九";
                if (d <= 10) return "初" + (d === 10 ? "十" : n1[d-1]);
                if (d < 20) return "十" + n1[(d % 10) - 1];
                if (d === 20) return "二十";
                if (d < 30) return "廿" + n1[(d % 10) - 1];
                return "三十";
            }
            let lunarDateCache={};
            function getLunarDate(date){
                const cleanDate = new Date(date);
                cleanDate.setHours(0, 0, 0, 0);
                const key=cleanDate.toISOString().split('T')[0];
                if(lunarDateCache[key])return lunarDateCache[key];
                let i,temp=0;const baseDate=new Date(1900,0,31);
                let offset=(cleanDate-baseDate)/86400000;
                for(i=1900;i<2101&&offset>0;i++){temp=getLunarYearDays(i);offset-=temp}if(offset<0){offset+=temp;i--}const year=i;const leapMonth=getLunarLeapMonth(year);let isLeap=false;for(i=1;i<13&&offset>0;i++){temp=getLunarMonthDays(year,i);offset-=temp;if(offset<0){break}if(leapMonth>0&&i===leapMonth){temp=getLunarLeapDays(year);offset-=temp;if(offset<0){isLeap=true;break}}}if(offset<0){offset+=temp}const month=i;
                const day=Math.round(offset)+1;
                const monthStr=(isLeap?'閏':'')+"正二三四五六七八九十冬臘"[month-1]+'月';
                const result={year:year,month:month,day:day,isLeap:isLeap,toString:monthStr+toChinaDate(day),dayString:toChinaDate(day)};
                lunarDateCache[key]=result;return result
            }
            function lunarToSolar(lunarYear,lunarMonth,lunarDay,isLeap=false){if(lunarYear<1900||lunarYear>2100)return null;const leap=getLunarLeapMonth(lunarYear);if(isLeap&&leap!==lunarMonth)return null;let daysOffset=0;for(let y=1900;y<lunarYear;y++){daysOffset+=getLunarYearDays(y)}for(let m=1;m<lunarMonth;m++){daysOffset+=getLunarMonthDays(lunarYear,m);if(leap>0&&m===leap){daysOffset+=getLunarLeapDays(lunarYear)}}if(isLeap){daysOffset+=getLunarMonthDays(lunarYear,lunarMonth)}daysOffset+=lunarDay-1;const baseDate=new Date(1900,0,31);return new Date(baseDate.getTime()+daysOffset*86400000)}
            let solarTermsCache={};
            function calculateAndCacheSolarTerms(year){if(year<2000||year>2099){solarTermsCache[year]={};return}const yearMap={};const Y=year-2000;solarTermConstants.forEach(([name,month,C])=>{const day=Math.floor(Y*0.2422+C)-Math.floor(Y/4);yearMap[`${year}-${month}-${day}`]=name});solarTermsCache[year]=yearMap}
            function getSolarTerm(year,month,day){if(!solarTermsCache[year]){calculateAndCacheSolarTerms(year)}return solarTermsCache[year][`${year}-${month}-${day}`]||null}
            function getHoliday(date) {
                const month = date.getMonth() + 1, dayOfMonth = date.getDate(), dayOfWeek = date.getDay();
                const gKey = `${month}-${dayOfMonth}`;
                if (gregorianHolidays[gKey]) return gregorianHolidays[gKey];
                const weekOfMonth = Math.ceil(dayOfMonth / 7);
                const fKey = `${month}-${weekOfMonth}-${dayOfWeek}`;
                if (floatingHolidays[fKey]) return floatingHolidays[fKey];
                const l = getLunarDate(date);
                if (l.day > 0) {
                    if (l.month === 12 && l.day === getLunarMonthDays(l.year, 12)) return "除夕";
                    const lKey = `${l.month}-${l.day}`;
                    if (lunarHolidays[lKey]) return lunarHolidays[lKey];
                }
                return null;
            }
            function getDailyGanzhi(date) {
                const cleanDate = new Date(date); cleanDate.setHours(0, 0, 0, 0);
                const baseDate = new Date(1900, 0, 31);
                const offset = Math.floor((cleanDate - baseDate) / 86400000);
                const dayStemIndex = (6 + (offset + 60000)) % 10;
                return { stemIndex: dayStemIndex };
            }
            // --- 星座計算 ---
            function getConstellation(date) { const m = date.getMonth() + 1, d = date.getDate(); for (let i = 0; i < signs.length; i++) { if (m < signs[i].m || (m === signs[i].m && d < signs[i].d)) return signs[i]; } return signs[0]; }
            // --- 時間輔助工具 ---
            const ShichenHelper = {
                hourStemStart: [0, 2, 4, 6, 8, 0, 2, 4, 6, 8],
                getData(date) {
                    const h = date.getHours(); const branchIndex = Math.floor(((h + 1) % 24) / 2);
                    const dayStemIndex = getDailyGanzhi(date).stemIndex;
                    const hourStemIndex = (this.hourStemStart[dayStemIndex] + branchIndex) % 10;
                    return { name: `${dizhi[branchIndex]}時`, char: dizhi[branchIndex], gz: `${tiangan[hourStemIndex]}${dizhi[branchIndex]}` };
                }
            };
            const TimeHelper = {
                timeRanges: [{h:23,p:'深夜'},{h:19,p:'夜晚'},{h:17,p:'傍晚'},{h:13,p:'下午'},{h:12,p:'中午'},{h:9,p:'上午'},{h:5,p:'清晨'},{h:0,p:'凌晨'}],
                getPeriodText(hour) { return this.timeRanges.find(range => hour >= range.h)?.p || ''; },
            };
            // --- 全局 DOM 元素與狀態 ---
            const allWidgetContainers = () => document.querySelectorAll('.widget-container');
            const actionButtons = document.getElementById('action-buttons');
            const editToolbar = document.getElementById('edit-toolbar');
            let isEditMode = false, activityTimeout, transformStates = {}, settingsState = {}, isWidgetAnimating = {};
            let selectedWidgets = new Set(), groupMoveHandle = null, groupRotateHandle = null, groupScaleHandle = null, initialGroupTransforms = {};
            // --- 跑馬燈參數與顏色變數的映射表 ---
            const marqueeParamColorMap = {
                '%YYYY%': '--year-color', '%ROC_YY%': '--year-color', '%MM%': '--month-color', '%DD%': '--day-color',
                '%WEEKDAY%': '--week-color', '%W_SHORT%': '--week-color', '%HH%': '--led-hour-color', '%hh%': '--led-hour-color',
                '%mm%': '--led-minute-color', '%ss%': '--led-second-color', '%ap_c%': '--led-period-color', '%L_GZ%': '--lunar-color',
                '%L_SX%': '--lunar-color', '%LM_C%': '--lunar-color', '%LD_C%': '--lunar-color', '%WEATHER_LOC%': '--holiday-color',
                '%WEATHER_DESC%': '--holiday-color', '%TEMP%': '--holiday-color', '%SUNRISE%': '--solarterm-color',
                '%SUNSET%': '--solarterm-color', '%MOON_PHASE%': '--moon-header-color', '%MOON_ICON%': '--moon-header-color',
                '%MOON_DAY%': '--moon-header-color', '%CONSTELLATION%': '--solarterm-color',
                '%SHICHEN_GZ%': '--lunar-color', '%SHICHEN_NAME%': '--lunar-color', '%SHICHEN_CHAR%': '--lunar-color'
            };
            // --- 預設設定 ---
            const userDefaultLayout = {
                "transforms": {
                    "calendar-container": { "visible": true, "width": 500, "height": 400, "left": 310, "top": 80, "scale": 1, "rotation": 0 },
                    "moon-phase-container": { "visible": false, "width": 500, "height": 400, "left": 10, "top": 80, "scale": 1, "rotation": 0 },
                    "led-clock-container": { "visible": true, "width": 300, "height": 98, "left": 10, "top": 80, "scale": 1, "rotation": 0 },
                    "analog-clock-container": { "visible": true, "width": 300, "height": 300, "left": 10, "top": 170, "scale": 1, "rotation": 0 },
                    "marquee-container-0": { "visible": true, "width": 800, "height": 80, "left": 10, "top": 10, "scale": 1, "rotation": 0 }
                },
                "settings": {
                    "calendar": { "visible": true, "showMoonIcon": true, "useLedFont": true, "colors": { "--bg-primary": "#000000", "--year-color": "#FF7000", "--month-color": "#3070a0", "--week-color": "#8830d0", "--day-color": "#ffffff", "--lunar-color": "#FFFF00", "--bg-secondary": "transparent", "--bg-hover": "rgba(55, 65, 81, 0.5)", "--border-color": "#374151", "--text-primary": "#F3F4F6", "--text-secondary": "#9CA3AF", "--text-muted": "#6B7280", "--holiday-color": "#6ee7b7", "--solarterm-color": "#fcd34d", "--yi-color": "#34D399", "--ji-color": "#F87171" } },
                    "ledClock": { "visible": true, "colonBlink": true, "colors": { "--led-hour-color": "#00ff00", "--led-minute-color": "#00ff00", "--led-second-color": "#00ff00", "--led-colon-color": "#00ff00", "--led-period-color": "#00ff00" } },
                    "analogClock": { "visible": true, "useLedFont": true, "smoothSeconds": false, "colors": { "--analog-face-color": "transparent", "--analog-hand-color": "#ffffff", "--analog-second-hand-color": "#ff3333", "--analog-tick-color": "#cccccc", "--analog-number-color": "#ffffff" } },
                    "moonPhase": { "visible": false, "useLedFont": true, "colors": { "--moon-light-color": "#f0e68c", "--moon-dark-color": "#222222", "--moon-header-color": "#a78bfa", "--moon-desc-color": "#d1d5db", "--moon-highlight-color": "#fcd34d" } },
                    "marquees": [
                        { "text": "%YYYY%/%ROC_YY%年%MM%月%DD%日%W_SHORT%%ap_c%%hh%%C(#00FF00, :)%%mm%%br%%C(#FFFF00, 農曆)%%LM_C%%LD_C%%br%%SHICHEN_NAME%%L_GZ%%L_SX%%MOON_ICON%%CONSTELLATION%%br%%WEATHER_LOC%%WEATHER_DESC%%TEMP%°C%br%日出%SUNRISE%%br%日落%SUNSET%", "speed": 80, "vertical": false, "direction": "left", "colors": {"default":"#FFFFFF"} }
                    ],
                    "marqueeGlobal": { "useLedFont": true },
                    "location": "taiwan",
                    "timedEffect": { "enabled": true, "intervalSeconds": 10, "type": "slide", "isRandom": false, "transitionEnabled": false }
                }
            };
            // ===================================================================
            // LED 時鐘模組
            // ===================================================================
            const LedClock = {
                svg: document.getElementById('led-clock-svg'), digits: {}, colons: {}, periodTextElement: null,
                lastTime: { h: -1, m: -1, s: -1 },
                segmentMap: [[1,1,1,1,1,1,0],[0,1,1,0,0,0,0],[1,1,0,1,1,0,1],[1,1,1,1,0,0,1],[0,1,1,0,0,1,1],[1,0,1,1,0,1,1],[1,0,1,1,1,1,1],[1,1,1,0,0,0,0],[1,1,1,1,1,1,1],[1,1,1,1,0,1,1]],
                segmentTransforms: ['translate(0, 0)','translate(132, 20) rotate(90)','translate(132, 140) rotate(90)','translate(0, 240)','translate(12, 140) rotate(90)','translate(12, 20) rotate(90)','translate(0, 120)'],
                baseViewBoxWidth: 0, aspectRatio: 0,
                createDigit(id, x, parentGroup, segmentClass) { const group = document.createElementNS('http://www.w3.org/2000/svg', 'g'); group.setAttribute('id', id); group.setAttribute('transform', `translate(${x}, 0)`); for (let i = 0; i < 7; i++) { const use = document.createElementNS('http://www.w3.org/2000/svg', 'use'); use.setAttribute('href', '#segment-shape'); use.setAttribute('class', `segment ${segmentClass}`); use.setAttribute('data-segment', String.fromCharCode(97 + i)); use.setAttribute('transform', this.segmentTransforms[i]); group.appendChild(use); } parentGroup.appendChild(group); return group; },
                createColon(id, x, parentGroup) { const group = document.createElementNS('http://www.w3.org/2000/svg', 'g'); group.setAttribute('id', id); group.setAttribute('transform', `translate(${x}, 0)`); ['translate(0, 60)', 'translate(0, 180)'].forEach(transform => { const dot = document.createElementNS('http://www.w3.org/2000/svg', 'use'); dot.setAttribute('href', '#colon-dot-shape'); dot.setAttribute('class', 'colon'); dot.setAttribute('transform', transform); group.appendChild(dot); }); parentGroup.appendChild(group); return group; },
                init() {
                    this.svg.innerHTML = ''; const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs'); defs.innerHTML = `<polygon id="segment-shape" points="16 0, 96 0, 112 16, 96 32, 16 32, 0 16" /><rect id="colon-dot-shape" x="-16" y="0" width="32" height="32" rx="5" ry="5" />`; this.svg.appendChild(defs); const digitWidth=160, colonWidth=48, digitSpacing=2, hourMinuteSpacing=0, secondsScale=0.25, minuteSecondSpacing=8; const viewportGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g'); this.svg.appendChild(viewportGroup); let currentX = 0; this.digits.h1 = this.createDigit('digit-h1', currentX, viewportGroup, 'segment-h'); currentX += digitWidth + digitSpacing; this.digits.h2 = this.createDigit('digit-h2', currentX, viewportGroup, 'segment-h'); currentX += digitWidth + hourMinuteSpacing; this.colons.h = this.createColon('colon-h', currentX, viewportGroup); currentX += colonWidth + hourMinuteSpacing; this.digits.m1 = this.createDigit('digit-m1', currentX, viewportGroup, 'segment-m'); currentX += digitWidth + digitSpacing; this.digits.m2 = this.createDigit('digit-m2', currentX, viewportGroup, 'segment-m'); const mainDigitsWidth = currentX + digitWidth; const secondsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g'); viewportGroup.appendChild(secondsGroup); this.digits.s1 = this.createDigit('digit-s1', 0, secondsGroup, 'segment-s'); this.digits.s2 = this.createDigit('digit-s2', digitWidth + digitSpacing, secondsGroup, 'segment-s'); this.periodTextElement = document.createElementNS('http://www.w3.org/2000/svg', 'text'); this.periodTextElement.setAttribute('class', 'period-text'); this.periodTextElement.setAttribute('dominant-baseline', 'hanging'); viewportGroup.appendChild(this.periodTextElement); const mainDigitHeight = 240 + 32; const scaledSecondsHeight = mainDigitHeight * secondsScale; const totalContentWidth = mainDigitsWidth + minuteSecondSpacing + Math.max((digitWidth * 2 + digitSpacing) * secondsScale, 110); this.baseViewBoxWidth = totalContentWidth + 20; this.aspectRatio = this.baseViewBoxWidth / mainDigitHeight; this.svg.setAttribute('viewBox', `0 0 ${this.baseViewBoxWidth} ${mainDigitHeight}`); viewportGroup.setAttribute('transform', 'translate(20, 0)'); secondsGroup.setAttribute('transform', `translate(${mainDigitsWidth + minuteSecondSpacing}, ${mainDigitHeight - scaledSecondsHeight}) scale(${secondsScale})`);
                    this.periodTextElement.setAttribute('x', mainDigitsWidth + minuteSecondSpacing - 20);
                    this.periodTextElement.setAttribute('y', 0); this.update(); setInterval(() => this.update(), 1000);
                },
                updateDigit(digitElement, number) { const pattern = this.segmentMap[number]; digitElement.querySelectorAll('.segment').forEach((segment, i) => { segment.style.opacity = pattern[i] ? '1' : '0.1'; }); },
                update() {
                    const now = new Date();
                    const s = now.getSeconds();

                    // --- 每秒執行的部分 ---
                    if (s !== this.lastTime.s) {
                        // 處理定時特效
                        const effectSettings = settingsState.timedEffect;
                        if (!isEditMode && effectSettings && effectSettings.enabled && s % effectSettings.intervalSeconds === 0) {
                            if (Object.values(isWidgetAnimating).some(v => v)) return;

                            if (effectSettings.type === 'layoutSwitch') {
                                if (layouts.length >= 2) {
                                    if (effectSettings.isRandom) {
                                        let randomIndex;
                                        do { randomIndex = Math.floor(Math.random() * layouts.length); } while (layouts.length > 1 && randomIndex === currentLayoutIndex);
                                        currentLayoutIndex = randomIndex;
                                    } else {
                                        currentLayoutIndex = nextLayoutIndex;
                                        nextLayoutIndex = (nextLayoutIndex + 1) % layouts.length;
                                    }
                                    const useTransition = settingsState.timedEffect?.transitionEnabled ?? false;
                                    if (useTransition) { animateLayoutChange(layouts[currentLayoutIndex], 1000, true); } 
                                    else { applyLayout(layouts[currentLayoutIndex], { ignoreTimedEffect: true }); saveCurrentSettings(true); }
                                }
                            } else if (effectSettings.type === 'slide') {
                                this.triggerSlideEffect();
                            }
                        }

                        // 更新秒數顯示和冒號閃爍
                        const sStr = String(s).padStart(2, '0');
                        this.updateDigit(this.digits.s1, parseInt(sStr[0]));
                        this.updateDigit(this.digits.s2, parseInt(sStr[1]));
                        const shouldBlink = settingsState.ledClock?.colonBlink ?? true;
                        const colonOpacity = shouldBlink ? (s % 2 === 0 ? '1' : '0.2') : '1';
                        this.colons.h.querySelectorAll('.colon').forEach(c => c.style.opacity = colonOpacity);
                        this.lastTime.s = s;
                    }

                    // --- 每分鐘執行的部分 ---
                    const m = now.getMinutes();
                    if (m !== this.lastTime.m) {
                        const mStr = String(m).padStart(2, '0');
                        this.updateDigit(this.digits.m1, parseInt(mStr[0]));
                        this.updateDigit(this.digits.m2, parseInt(mStr[1]));
                        this.lastTime.m = m;
                    }

                    // --- 每小時執行的部分 ---
                    const h = now.getHours();
                    if (h !== this.lastTime.h) {
                        if (this.periodTextElement) { this.periodTextElement.textContent = TimeHelper.getPeriodText(h); }
                        let h12 = h % 12; if (h12 === 0) h12 = 12;
                        const hStr = String(h12).padStart(2, '0');
                        this.updateDigit(this.digits.h1, parseInt(hStr[0]));
                        this.updateDigit(this.digits.h2, parseInt(hStr[1]));
                        this.lastTime.h = h;
                    }
                },
                triggerSlideEffect() {
                    let targets = [];
                    allWidgetContainers().forEach(el => {
                        if (transformStates[el.id]?.visible && !el.classList.contains('marquee-widget')) targets.push(el.id);
                    });
                    MarqueeManager.instances.forEach(instance => {
                        if (transformStates[instance.container.id]?.visible && !instance.isScrolling) targets.push(instance.container.id);
                    });
                    if (targets.length === 0) return;
                    const move = { up: 'translateY(-100vh)', down: 'translateY(100vh)', left: 'translateX(-100vw)', right: 'translateX(100vw)' };
                    const directions = Object.keys(move);
                    const duration = 700;
                    targets.forEach(id => {
                        const el = document.getElementById(id);
                        if (!el || isWidgetAnimating[id]) return;
                        const direction = directions[Math.floor(Math.random() * directions.length)];
                        isWidgetAnimating[id] = true;
                        const originalTransform = el.style.transform;
                        const originalTransition = el.style.transition;
                        el.style.transition = `transform ${duration}ms ease-in-out`;
                        el.style.transform = `${originalTransform} ${move[direction]}`;
                        setTimeout(() => {
                            el.style.transition = 'none';
                            el.style.transform = originalTransform;
                            setTimeout(() => {
                                el.style.transition = originalTransition;
                                isWidgetAnimating[id] = false;
                            }, 50);
                        }, duration);
                    });
                }
            };
            // ===================================================================
            // 指針時鐘模組
            // ===================================================================
            const AnalogClock = {
                lastSecond: -1,
                hourHand: document.querySelector('#analog-clock-container .hour-hand'),
                minuteHand: document.querySelector('#analog-clock-container .minute-hand'),
                secondHand: document.querySelector('#analog-clock-container .second-hand'),
                ticksContainer: document.getElementById('ticks-container'),
                animationFrameId: null,
                init() {
                    this.ticksContainer.innerHTML = '';
                    const useLed = settingsState.analogClock?.useLedFont ?? true;
                    for (let i = 1; i <= 60; i++) {
                        const isHour = i % 5 === 0, rotation = i * 6;
                        const wrapper = document.createElement('div');
                        wrapper.className = 'tick-wrapper'; wrapper.style.transform = `rotate(${rotation}deg)`;
                        const tick = document.createElement('div');
                        tick.className = isHour ? 'tick tick-hour' : 'tick tick-minute';
                        wrapper.appendChild(tick);
                        if (isHour) {
                            wrapper.style.setProperty('--rotation', `${rotation}deg`);
                            const numDiv = document.createElement('div'); numDiv.className = 'number';
                            const numberText = String(i / 5);
                            const numberColor = getComputedStyle(document.documentElement).getPropertyValue('--analog-number-color').trim() || '#ffffff';
                            if (useLed) {
                                const clockState = transformStates['analog-clock-container'];
                                const svgHeight = clockState ? clockState.width * 0.08 : 16;
                                numDiv.innerHTML = `<div>${generateLedSvg(numberText, { height: svgHeight, color: numberColor })}</div>`;
                            } else {
                                numDiv.innerHTML = `<div style="transform: rotate(calc(-1 * var(--rotation))); color: ${numberColor}; font-size: 1.2em; font-weight: bold;">${numberText}</div>`;
                            }
                            wrapper.appendChild(numDiv);
                        }
                        this.ticksContainer.appendChild(wrapper);
                    }
                    if (!this.animationFrameId) this.update();
                },
                update() {
                    const now = new Date();
                    const smooth = settingsState.analogClock?.smoothSeconds ?? false;

                    if (!smooth) {
                        const currentSecond = now.getSeconds();
                        if (currentSecond === this.lastSecond) {
                            this.animationFrameId = requestAnimationFrame(() => this.update());
                            return;
                        }
                        this.lastSecond = currentSecond;
                    }

                    const s = smooth ? now.getSeconds() + now.getMilliseconds() / 1000 : now.getSeconds();
                    const m = now.getMinutes() + s / 60;
                    const h = now.getHours() % 12 + m / 60;
                    this.hourHand.style.transform = `translateX(-50%) rotate(${(h / 12) * 360}deg)`;
                    this.minuteHand.style.transform = `translateX(-50%) rotate(${(m / 60) * 360}deg)`;
                    this.secondHand.style.transform = `translateX(-50%) rotate(${(s / 60) * 360}deg)`;
                    this.animationFrameId = requestAnimationFrame(() => this.update());
                }
            };
            // ===================================================================
            // LED 數字 SVG 產生器
            // ===================================================================
            function generateLedSvg(text, config = {}) {
                const { height = 24, color = '#FFFFFF', letterSpacing = 16 } = config;
                const id_suffix = Math.random().toString(36).substring(2, 9);
                const segmentId = `led-segment-${id_suffix}`, colonId = `led-colon-${id_suffix}`;
                const segmentMap = [[1,1,1,1,1,1,0],[0,1,1,0,0,0,0],[1,1,0,1,1,0,1],[1,1,1,1,0,0,1],[0,1,1,0,0,1,1],[1,0,1,1,0,1,1],[1,0,1,1,1,1,1],[1,1,1,0,0,0,0],[1,1,1,1,1,1,1],[1,1,1,1,0,1,1]];
                const segmentTransforms = ['translate(0, 0)','translate(132, 20) rotate(90)','translate(132, 140) rotate(90)','translate(0, 240)','translate(12, 140) rotate(90)','translate(12, 20) rotate(90)','translate(0, 120)'];
                const digitBaseWidth = 144, digitBaseHeight = 272, colonBaseWidth = 48;
                let svgContent = '', currentX = 0;
                for (const char of String(text)) {
                    if (/\d/.test(char)) {
                        const digit = parseInt(char, 10);
                        if (digit >= 0 && digit <= 9) {
                            const pattern = segmentMap[digit];
                            let digitGroup = `<g transform="translate(${currentX}, 0)">`;
                            for (let i = 0; i < 7; i++) digitGroup += `<use href="#${segmentId}" opacity="${pattern[i] ? '1' : '0.1'}" transform="${segmentTransforms[i]}" />`;
                            digitGroup += `</g>`; svgContent += digitGroup;
                        }
                        currentX += digitBaseWidth + letterSpacing;
                    } else if (char === ':') {
                        svgContent += `<g transform="translate(${currentX}, 0)"><use href="#${colonId}" transform="translate(0, 60)" /><use href="#${colonId}" transform="translate(0, 180)" /></g>`;
                        currentX += colonBaseWidth + letterSpacing;
                    } else if (['/', '-', '.'].includes(char)) {
                        const separatorWidth = 60, entity = { '/': '/', '-': '—', '.': '.' }[char];
                        svgContent += `<text x="${currentX + separatorWidth / 2}" y="${digitBaseHeight / 2}" text-anchor="middle" dominant-baseline="central" font-size="${digitBaseHeight * 0.9}" font-family="'Courier New', Courier, monospace" font-weight="bold">${entity}</text>`;
                        currentX += separatorWidth + letterSpacing;
                    }
                }
                const totalWidth = currentX > 0 ? currentX - letterSpacing : 0;
                if (totalWidth === 0) return '';
                const padding = 16, finalWidth = ((totalWidth + padding * 2) / digitBaseHeight) * height;
                return `<svg viewBox="-${padding} 0 ${totalWidth + padding * 2} ${digitBaseHeight}" data-text="${text}" height="${height}px" width="${finalWidth}px" fill="${color}" style="vertical-align: middle; display: inline-block;"><defs><polygon id="${segmentId}" points="16 0, 96 0, 112 16, 96 32, 16 32, 0 16" /><rect id="${colonId}" x="-16" y="0" width="32" height="32" rx="5" ry="5" /></defs>${svgContent}</svg>`.replace(/\n\s*/g, '');
            }
            function getLedHTML(text, useLed, options = {}) {
                if (!useLed) return String(text).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const { color = '#FFFFFF', fontSize = 16, heightMultiplier = 1.1, defaultSpan = true } = options;
                let resultHTML = '';
                const parts = String(text).split(/(\d+[\d:./-]*)/);
                parts.forEach(part => {
                    if (/^\d+[\d:./-]*$/.test(part) && part.trim() !== '') {
                        resultHTML += generateLedSvg(part, { height: fontSize * heightMultiplier, color: color });
                    } else if (part) {
                        const escapedPart = part.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        resultHTML += defaultSpan ? `<span style="color:${color};">${escapedPart}</span>` : escapedPart;
                    }
                });
                return resultHTML;
            }
            function applyLedToStaticContent(containerElement) {
                if (containerElement.dataset.ledProcessed) return;
                const walker = document.createTreeWalker(containerElement, NodeFilter.SHOW_TEXT, null, false);
                const nodesToProcess = [];
                let node;
                while (node = walker.nextNode()) {
                    if (node.parentElement.closest('script, style, svg, [data-led-processed]')) continue;
                    if (/\d/.test(node.nodeValue)) nodesToProcess.push(node);
                }
                nodesToProcess.forEach(node => {
                    const parent = node.parentNode;
                    if (!parent) return;
                    const parts = node.nodeValue.split(/(\d+[\d:./-]*)/);
                    if (parts.length <= 1) return;
                    const fragment = document.createDocumentFragment();
                    parts.forEach(part => {
                        if (/^\d+[\d:./-]*$/.test(part) && part.trim() !== '') {
                            const color = getComputedStyle(parent).color || '#FFFFFF';
                            const fontSize = parseFloat(getComputedStyle(parent).fontSize) || 16;
                            const template = document.createElement('template');
                            const svgHTML = generateLedSvg(part, { height: fontSize * 1.1, color: color }).trim();
                            if (svgHTML) {
                                template.innerHTML = svgHTML;
                                if (template.content.firstChild) {
                                    template.content.firstChild.dataset.ledProcessed = 'true';
                                    fragment.appendChild(template.content.firstChild);
                                }
                            } else { fragment.appendChild(document.createTextNode(part)); }
                        } else if (part) { fragment.appendChild(document.createTextNode(part)); }
                    });
                    parent.replaceChild(fragment, node);
                });
                containerElement.dataset.ledProcessed = 'true';
            }
            // ===================================================================
            // 統一的日曆標題渲染函數
            // ===================================================================
            function renderCalendarTitle(element, year, useLed, ledHeight, ledColor, defaultFontSize, defaultColor) {
                element.innerHTML = useLed
                    ? generateLedSvg(String(year), {height: ledHeight, color: ledColor})
                    : `<span style="font-size: ${defaultFontSize}; color: ${defaultColor}; line-height: 1; font-weight: 700;">${year}</span>`;
            }
            // ===================================================================
            // 跑馬燈模組 (Class)
            // ===================================================================
            class MarqueeInstance {
                constructor(containerId, index) {
                    this.container = document.getElementById(containerId);
                    this.mainContainer = this.container.querySelector('main');
                    this.innerDiv = this.container.querySelector('.marquee-inner');
                    this.index = index;
                    this.animationStyleTag = document.createElement('style');
                    document.head.appendChild(this.animationStyleTag);
                    this.rebuildTimeout = null;
                    this.isScrolling = false;

                    // 參數與更新頻率的映射
                    this.paramToFrequency = {
                        s: ['%ss%', '%s%'],
                        m: ['%mm%', '%m%', '%HH%', '%H%', '%hh%', '%h%', '%AP%', '%ap%', '%ap_c%', '%SHICHEN_GZ%', '%SHICHEN_NAME%', '%SHICHEN_CHAR%'],
                        d: ['%YYYY%', '%YY%', '%ROC_YY%', '%MM%', '%M%', '%DD%', '%D%', '%WEEKDAY%', '%W_SHORT%', '%W_CHAR%', '%W_NUM%', '%CONSTELLATION%', '%L_GZ%', '%L_SX%', '%LM_C%', '%LD_C%', '%MOON_PHASE%', '%MOON_ICON%', '%MOON_DAY%'],
                        w: ['%WEATHER_LOC%', '%WEATHER_DESC%', '%TEMP%', '%SUNRISE%', '%SUNSET%']
                    };
                    // 根據頻率分類儲存對應的 span 元素
                    this.spansByFrequency = { s: [], m: [], d: [], w: [] };
                }

                // 新增：將跑馬燈內的參數 span 元素進行分類儲存
                _categorizeSpans() {
                    this.spansByFrequency = { s: [], m: [], d: [], w: [] };
                    this.innerDiv.querySelectorAll('[data-time-key]').forEach(span => {
                        const key = span.dataset.timeKey;
                        if (this.paramToFrequency.s.includes(key)) this.spansByFrequency.s.push(span);
                        else if (this.paramToFrequency.m.includes(key)) this.spansByFrequency.m.push(span);
                        else if (this.paramToFrequency.d.includes(key)) this.spansByFrequency.d.push(span);
                        else if (this.paramToFrequency.w.includes(key)) this.spansByFrequency.w.push(span);
                    });
                }

                buildInitialHTML(text) {
                    const settings = settingsState.marquees[this.index], isVertical = settings.vertical, useLedGlobal = settingsState.marqueeGlobal?.useLedFont ?? true, defaultColor = (settings.colors && settings.colors.default) ? settings.colors.default : '#FFFFFF';
                    const processMarqueeChunk = (chunk) => {
                        if (!useLedGlobal) return `<span class="marquee-plain-text" style="color:${defaultColor}">${chunk.replace(/ /g, '\u00A0')}</span>`;
                        let processedHTML = '';
                        const parts = chunk.split(/(\d+[\d:.]*)/);
                        for (const part of parts) {
                            if (/^\d+[\d:.]*$/.test(part) && part.trim() !== '') {
                                const widgetState = transformStates[this.container.id];
                                const svgHeight = widgetState ? widgetState.height * 0.70 : 28;
                                processedHTML += generateLedSvg(part, { height: svgHeight, color: defaultColor });
                            } else if (part) {
                                processedHTML += `<span class="marquee-plain-text" style="color:${defaultColor}">${part.replace(/ /g, '\u00A0')}</span>`;
                            }
                        }
                        return processedHTML;
                    };
                    // 不再呼叫 getReplacements()，而是使用 Manager 提供的快取
                    const replacements = MarqueeManager._cachedReplacements;
                    const paramRegex = new RegExp(`%C\\(#([0-9a-fA-F]{6}),\\s*([^%)]+)\\)%|${Object.keys(marqueeParamColorMap).map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')}|%br%`, 'g');
                    let resultHTML = '', lastIndex = 0, match;
                    const ledParams = ['%HH%', '%H%', '%hh%', '%h%', '%mm%', '%m%', '%ss%', '%s%', '%ROC_YY%', '%YYYY%', '%YY%', '%MM%', '%M%', '%DD%', '%D%', '%TEMP%', '%SUNRISE%', '%SUNSET%'];
                    while ((match = paramRegex.exec(text)) !== null) {
                        if (match.index > lastIndex) { resultHTML += processMarqueeChunk(text.substring(lastIndex, match.index)); }
                        const param = match[0], colorHex = match[1], colorText = match[2];
                        if (colorHex && colorText) {
                            if (useLedGlobal && /^[\d:]+$/.test(colorText)) {
                                const widgetState = transformStates[this.container.id];
                                const svgHeight = widgetState ? widgetState.height * 0.70 : 28;
                                resultHTML += `<span>${generateLedSvg(colorText, { height: svgHeight, color: '#' + colorHex })}</span>`;
                            } else {
                                resultHTML += `<span class="marquee-plain-text" style="color:#${colorHex}">${colorText.replace(/ /g, '\u00A0')}</span>`;
                            }
                        } else if (param === '%br%') {
                            if (isVertical) resultHTML += '</div><div>';
                        } else if (replacements[param] !== undefined) { // 確保 replacements 有值
                            const cssVar = marqueeParamColorMap[param];
                            const color = cssVar ? getComputedStyle(document.documentElement).getPropertyValue(cssVar).trim() : defaultColor;
                            const replacementContent = String(replacements[param] || '');
                            if (useLedGlobal && ledParams.includes(param) && /^[\d:]+$/.test(replacementContent)) {
                                const widgetState = transformStates[this.container.id];
                                const svgHeight = widgetState ? widgetState.height * 0.70 : 28;
                                resultHTML += `<span data-time-key="${param}">${generateLedSvg(replacementContent, { height: svgHeight, color: color })}</span>`;
                            } else if (param === '%MOON_ICON%') {
                                resultHTML += `<span data-time-key="${param}">${replacementContent}</span>`;
                            } else {
                                resultHTML += `<span data-time-key="${param}" style="color:${color}">${replacementContent}</span>`;
                            }
                        }
                        lastIndex = paramRegex.lastIndex;
                    }
                    if (lastIndex < text.length) { resultHTML += processMarqueeChunk(text.substring(lastIndex)); }
                    return isVertical ? `<div>${resultHTML}</div>` : resultHTML;
                }

                // 修改：接收狀態和快取資料，進行目標式更新
                updateContent(status, replacements) {
                    const updateSpan = (span) => {
                        const key = span.dataset.timeKey;
                        if (replacements[key] === undefined) return;
                        const useLed = settingsState.marqueeGlobal?.useLedFont ?? true;
                        const ledParams = ['%HH%', '%H%', '%hh%', '%h%', '%mm%', '%m%', '%ss%', '%s%', '%ROC_YY%', '%YYYY%', '%YY%', '%MM%', '%M%', '%DD%', '%D%', '%TEMP%', '%SUNRISE%', '%SUNSET%'];
                        const newText = String(replacements[key]);
                        if (useLed && ledParams.includes(key) && /^[\d:]+$/.test(newText)) {
                            const svgEl = span.querySelector('svg');
                            if (!svgEl || svgEl.dataset.text !== newText) {
                                 const widgetState = transformStates[this.container.id];
                                 const svgHeight = widgetState ? widgetState.height * 0.70 : 28;
                                 const color = svgEl ? svgEl.getAttribute('fill') : (marqueeParamColorMap[key] ? getComputedStyle(document.documentElement).getPropertyValue(marqueeParamColorMap[key]).trim() : '#FFFFFF');
                                 span.innerHTML = generateLedSvg(newText, { height: svgHeight, color: color });
                            }
                        } else if (key === '%MOON_ICON%') {
                            if (span.innerHTML !== newText) span.innerHTML = newText;
                        } else {
                            if (span.textContent !== newText) span.textContent = newText;
                        }
                    };
                    
                    if (status.s) this.spansByFrequency.s.forEach(updateSpan);
                    if (status.m) this.spansByFrequency.m.forEach(updateSpan);
                    if (status.d) this.spansByFrequency.d.forEach(updateSpan);
                    if (status.w) this.spansByFrequency.w.forEach(updateSpan);
                }

                rebuildAnimation() {
                    clearTimeout(this.rebuildTimeout);
                    this.innerDiv.style.animation = ''; this.isScrolling = false;
                    const settings = settingsState.marquees[this.index]; if (!settings) return;
                    if (/^%WEATHER_|%SUNRISE%|%SUNSET%|%TEMP%/.test(settings.text) && !weatherDataLoaded) {
                        this.innerDiv.style.transform = 'translateX(0) translateY(0)';
                        this.innerDiv.innerHTML = `<div class="marquee-text-instance">${this.buildInitialHTML(settings.text)}</div>`;
                        return;
                    }
                    this.rebuildTimeout = setTimeout(() => {
                        this.animationStyleTag.innerHTML = ''; this.innerDiv.innerHTML = '';
                        this.innerDiv.style.transform = 'translateX(0) translateY(0) translateZ(0)';
                        if (!settings.text || !settings.text.trim()) return;
                        const { text, vertical: isVertical, speed, direction } = settings;
                        this.innerDiv.style.flexDirection = isVertical ? 'column' : 'row';
                        this.innerDiv.style.width = isVertical ? '100%' : 'fit-content';
                        this.mainContainer.style.alignItems = isVertical ? 'flex-start' : 'center';
                        const instance1 = document.createElement('div');
                        instance1.className = 'marquee-text-instance';
                        instance1.style.whiteSpace = isVertical ? 'normal' : 'nowrap';
                        instance1.style.textAlign = isVertical ? 'center' : 'left';
                        if (isVertical) instance1.style.display = 'block';
                        instance1.innerHTML = this.buildInitialHTML(text);
                        this.innerDiv.appendChild(instance1);
                        instance1.getBoundingClientRect();
                        const contentMeasure = isVertical ? instance1.offsetHeight : instance1.offsetWidth;
                        const containerMeasure = isVertical ? this.mainContainer.offsetHeight : this.mainContainer.offsetWidth;
                        if (contentMeasure <= containerMeasure) {
                            this.isScrolling = false;
                            if (!isVertical && instance1.scrollWidth > this.mainContainer.clientWidth) {
                                this.container.style.fontSize = `${parseFloat(getComputedStyle(this.container).fontSize) * (this.mainContainer.clientWidth / instance1.scrollWidth) * 0.98}px`;
                            }
                        } else {
                            this.isScrolling = true;
                            this.innerDiv.appendChild(instance1.cloneNode(true));
                        }
                        this._categorizeSpans();

                        if (!this.isScrolling) return;
                        const travelDistance = contentMeasure; if (travelDistance <= 0) return;
                        const duration = travelDistance / (parseInt(speed, 10) || 80);
                        const animName = `marquee-${this.index}-${Date.now()}`;
                        let fromTransform, toTransform;
                        switch(direction) {
                            case 'right': fromTransform = `translateX(-${travelDistance}px)`; toTransform = `translateX(0px)`; break;
                            case 'up': fromTransform = `translateY(0px)`; toTransform = `translateY(-${travelDistance}px)`; break;
                            case 'down': fromTransform = `translateY(-${travelDistance}px)`; toTransform = `translateY(0px)`; break;
                            default: fromTransform = `translateX(0px)`; toTransform = `translateX(-${travelDistance}px)`; break;
                        }
                        this.animationStyleTag.innerHTML = `@keyframes ${animName} { from { transform: ${fromTransform} translateZ(0); } to { transform: ${toTransform} translateZ(0); }}`;
                        this.innerDiv.style.animation = `${animName} ${duration}s linear infinite`;
                        this.innerDiv.style.animationPlayState = isEditMode ? 'paused' : 'running';
                    }, 50);
                }
                 setPlayState(shouldPlay) { this.innerDiv.style.animationPlayState = shouldPlay ? 'running' : 'paused'; }
            }
            // ===================================================================
            // 月相 SVG 產生器
            // ===================================================================
            function getMoonPhaseSVG(lunarDay, size = '100px', context = 'widget') {
                const phase = (lunarDay - 1) / 29.53, r = 50, cx = 50, cy = 50;
                const light = getComputedStyle(document.documentElement).getPropertyValue('--moon-light-color').trim() || '#f0e68c';
                const dark = getComputedStyle(document.documentElement).getPropertyValue('--moon-dark-color').trim() || '#222222';
                const cos_angle = Math.cos(phase * 2 * Math.PI + Math.PI);
                const base = phase > 0.5 ? `<rect x="0" y="0" width="${cx}" height="${r*2}" fill="${light}" /><rect x="${cx}" y="0" width="${cx}" height="${r*2}" fill="${dark}" />` : `<rect x="0" y="0" width="${cx}" height="${r*2}" fill="${dark}" /><rect x="${cx}" y="0" width="${cx}" height="${r*2}" fill="${light}" />`;
                const terminator = `<ellipse cx="${cx}" cy="${cy}" rx="${r * Math.abs(cos_angle)}" ry="${r}" fill="${cos_angle > 0 ? light : dark}" />`;
                const id = `moon-clip-${context}-${lunarDay}-${size.replace(/[^a-zA-Z0-9]/g, '')}`;
                return `<svg width="${size}" height="${size}" viewBox="0 0 100 100" style="filter: drop-shadow(0 0 10px ${light}33);"><defs><clipPath id="${id}"><circle cx="${cx}" cy="${cy}" r="${r}" /></clipPath></defs><g clip-path="url(#${id})">${base}${terminator}</g></svg>`;
            }
            // ===================================================================
            // Modal 彈出視窗與 UI 互動 (Refactored)
            // ===================================================================
            function showModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modalId === 'modal-backdrop-marquee-params' || modalId === 'modal-backdrop-explanation') {
                    const useLed = modalId === 'modal-backdrop-marquee-params' ? (settingsState.marqueeGlobal?.useLedFont ?? true) : (settingsState.calendar?.useLedFont ?? true);
                    if (useLed) applyLedToStaticContent(modal.querySelector('.modal-content'));
                }
                modal.classList.add('show');
            }
            function hideModal(modalId) { document.getElementById(modalId).classList.remove('show'); }
            const promptModal=document.getElementById('modal-backdrop-prompt'),promptTitle=document.getElementById('prompt-title'),promptMessage=document.getElementById('prompt-message'),promptInput=document.getElementById('prompt-input'),promptOkBtn=document.getElementById('prompt-ok-btn'),promptCancelBtn=document.getElementById('prompt-cancel-btn');
            let promptCallback=null;
            function _setPromptMessage(message) {
                const el = promptMessage;
                const useLed = true;
                el.innerHTML = getLedHTML(message, useLed, { fontSize: parseFloat(getComputedStyle(el).fontSize) || 16, color: getComputedStyle(el).color || '#d1d5db', defaultSpan: false });
                el.style.display = message ? 'block' : 'none';
            }
            function _configurePromptModal(config) {
                promptTitle.textContent = config.title;
                _setPromptMessage(config.message);
                promptInput.style.display = config.showInput ? 'block' : 'none';
                if (config.showInput) promptInput.value = config.defaultValue || '';
                promptCancelBtn.style.display = config.showCancel ? 'inline-block' : 'none';
                promptOkBtn.textContent = config.okText || '確定';
                promptCallback = config.callback;
                showModal('modal-backdrop-prompt');
                if (config.showInput) setTimeout(() => promptInput.focus(), 100);
            }
            function showAlert(title, message) { _configurePromptModal({ title, message, showInput: false, showCancel: false, okText: '確定' }); }
            function showPrompt(title, message, defaultValue, callback) { _configurePromptModal({ title, message, defaultValue, callback, showInput: true, showCancel: true, okText: '確定' }); }
            function showConfirm(title, message, callback) { _configurePromptModal({ title, message, callback: (result) => callback(result !== null), showInput: false, showCancel: true, okText: '確認' }); }
            promptOkBtn.addEventListener('click',()=>{if(promptCallback)promptCallback(promptInput.value);hideModal('modal-backdrop-prompt')});
            promptCancelBtn.addEventListener('click',()=>{if(promptCallback)promptCallback(null);hideModal('modal-backdrop-prompt')});
            function showDayDetailModal(dateString){
                if(isEditMode)return;
                const date=new Date(dateString);
                const lunar=getLunarDate(date);
                const holiday=getHoliday(date);
                const solarTerm=getSolarTerm(date.getFullYear(),date.getMonth()+1,date.getDate());
                const constellationInfo = getConstellation(date);
                const useLed = settingsState.calendar?.useLedFont ?? true;
                if (useLed) {
                    const yearSVG = generateLedSvg(String(date.getFullYear()), {height: 22, color: 'white'});
                    const monthSVG = generateLedSvg(String(date.getMonth() + 1), {height: 22, color: 'white'});
                    const daySVG = generateLedSvg(String(date.getDate()), {height: 22, color: 'white'});
                    document.getElementById('modal-gregorian-date').innerHTML = `${yearSVG}<span class="led-text-unit">年</span>${monthSVG}<span class="led-text-unit">月</span>${daySVG}<span class="led-text-unit">日 星期${"日一二三四五六"[date.getDay()]}</span>`;
                } else {
                     document.getElementById('modal-gregorian-date').innerHTML = `<span style="font-size: 1.5em; line-height:1.2;">${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日 星期${"日一二三四五六"[date.getDay()]}</span>`;
                }
                const rocYear = date.getFullYear()-1911;
                const rocYearHTML = useLed ? generateLedSvg(String(rocYear), {height: 20, color: '#a5b4fc'}) : rocYear;
                document.getElementById('modal-lunar-date').innerHTML = `民國 ${rocYearHTML} 年 / 農曆 ${lunar.toString}`;
                const modalConstellationEl = document.getElementById('modal-constellation');
                if (constellationInfo) {
                    const text = `星座 ${constellationInfo.sign} (${constellationInfo.range})`;
                    const fontSize = parseFloat(getComputedStyle(modalConstellationEl).fontSize) || 16;
                    const color = getComputedStyle(modalConstellationEl).color || 'white';
                    modalConstellationEl.innerHTML = getLedHTML(text, useLed, { fontSize, color, defaultSpan: false });
                    modalConstellationEl.style.display = 'block';
                } else { modalConstellationEl.style.display = 'none'; }
                const modalHolidayEl=document.getElementById('modal-holiday');
                modalHolidayEl.textContent=holiday||''; modalHolidayEl.style.display=holiday?'block':'none';
                if(holiday)modalHolidayEl.dataset.key=holiday;
                const modalSolarTermEl=document.getElementById('modal-solarterm');
                modalSolarTermEl.textContent=solarTerm||''; modalSolarTermEl.style.display=solarTerm?'block':'none';
                if(solarTerm)modalSolarTermEl.dataset.key=solarTerm;
                const formatTime = (dateStr) => dateStr ? new Date(dateStr).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) : '讀取中...';
                const sunriseTime = Weather.data?.daily?.sunrise?.[0] ? formatTime(Weather.data.daily.sunrise[0]) : '讀取中...';
                const sunsetTime = Weather.data?.daily?.sunset?.[0] ? formatTime(Weather.data.daily.sunset[0]) : '讀取中...';
                const isTimeFormat = (str) => /^[\d:]+$/.test(str);
                const formatTimeForDisplay = (timeStr) => useLed && isTimeFormat(timeStr) ? generateLedSvg(timeStr, {height: 26, color: 'white'}) : timeStr;
                document.getElementById('modal-sunrise-time').innerHTML = formatTimeForDisplay(sunriseTime);
                document.getElementById('modal-sunset-time').innerHTML = formatTimeForDisplay(sunsetTime);
                const moonDetails = moonPhaseData[lunar.day] || { n: '未知', a: '', d: '' };
                const moonName = moonDetails.a ? `${moonDetails.n}(${moonDetails.a})` : moonDetails.n;
                document.getElementById('modal-moon-icon').innerHTML = getMoonPhaseSVG(lunar.day, '64px', 'day-detail');
                document.getElementById('modal-moon-phase-name').textContent = moonName;
                const moonDescEl = document.getElementById('modal-moon-phase-desc');
                if (moonDetails.d) {
                    const fontSize = parseFloat(getComputedStyle(moonDescEl).fontSize) || 16;
                    const color = getComputedStyle(moonDescEl).color || 'white';
                    moonDescEl.innerHTML = getLedHTML(moonDetails.d, useLed, { fontSize, color, defaultSpan: false });
                    moonDescEl.style.display = 'block';
                } else { moonDescEl.style.display = 'none'; }
                updateCountdowns(date);
                showModal('modal-backdrop-day')
            }
            function showExplanationModal(title,content){if(isEditMode)return;document.getElementById('explanation-title').textContent=title;document.getElementById('explanation-content').textContent=content;showModal('modal-backdrop-explanation')}
            function getAllSolarTermsForYear(year){if(!solarTermsCache[year])calculateAndCacheSolarTerms(year);return Object.entries(solarTermsCache[year]).map(([key,name])=>{const[y,m,d]=key.split('-').map(Number);return{date:new Date(y,m-1,d),name}}).sort((a,b)=>a.date-b.date)}
            function getAllHolidaysForYear(year){
                let holidays = [];
                Object.entries(lunarHolidays).forEach(([key, name]) => { [year, year - 1].forEach(lunarYear => { const [m, d] = key.split('-'); const solarDate = lunarToSolar(lunarYear, parseInt(m), parseInt(d)); if (solarDate && solarDate.getFullYear() === year) holidays.push({ date: solarDate, name }); }); });
                [year, year - 1].forEach(lunarYear => { const eveDate = lunarToSolar(lunarYear, 12, getLunarMonthDays(lunarYear, 12)); if (eveDate && eveDate.getFullYear() === year) holidays.push({ date: eveDate, name: "除夕" }); });
                Object.entries(floatingHolidays).forEach(([key, name]) => { const [m, week, dayOfWeek] = key.split('-').map(Number); const month = m - 1; let firstOfMonth = new Date(year, month, 1); let holidayDate = new Date(year, month, 1 + ((dayOfWeek - firstOfMonth.getDay() + 7) % 7) + (week - 1) * 7); if (holidayDate.getMonth() === month) holidays.push({ date: holidayDate, name }); });
                return Array.from(new Map(holidays.map(h => [h.date.toISOString().split('T')[0], h])).values()).sort((a, b) => a.date - b.date);
            }
            function updateCountdowns(currentDate){
                const today = new Date(currentDate); today.setHours(0,0,0,0);
                const useLed = settingsState.calendar?.useLedFont ?? true;
                const formatCountdownText=(items,type)=>{
                    const futureEvents=items.filter(item=>item.date>=today);
                    if(futureEvents.length===0)return`找不到${today.getFullYear()+1}年的${type}資料`;
                    const firstEvent=futureEvents[0];
                    const diffDays=Math.ceil((firstEvent.date.getTime()-today.getTime())/86400000);
                    const daysHTML = useLed ? generateLedSvg(String(diffDays), {height: 20, color: 'white'}) : `<span style="font-size: 1.2em;">${diffDays}</span>`;
                    if(diffDays===0){
                        if(futureEvents[1]) {
                             const nextDiffDays = Math.ceil((futureEvents[1].date - today) / 86400000);
                             const nextDaysHTML = useLed ? generateLedSvg(String(nextDiffDays), {height: 20, color: 'white'}) : `<span style="font-size: 1.2em;">${nextDiffDays}</span>`;
                             return `<div class="countdown-text-container">今天是 ${firstEvent.name}，距離下個${type} [${futureEvents[1].name}] 還有 ${nextDaysHTML} 天</div>`;
                        }
                        return `今天是 ${firstEvent.name}！`;
                    }
                    return `<div class="countdown-text-container">距離 ${firstEvent.name} 還有 ${daysHTML} 天</div>`;
                };
                let allHolidays=[...getAllHolidaysForYear(today.getFullYear()),...getAllHolidaysForYear(today.getFullYear()+1)];
                let allSolarTerms=[...getAllSolarTermsForYear(today.getFullYear()),...getAllSolarTermsForYear(today.getFullYear()+1)];
                document.getElementById('countdown-holiday-text').innerHTML=formatCountdownText(allHolidays,'節日');
                document.getElementById('countdown-solarterm-text').innerHTML=formatCountdownText(allSolarTerms,'節氣');
            }
        const pickerYearEl=document.getElementById('picker-year'),pickerMonthGridEl=document.getElementById('picker-month-grid');
        let pickerYear=new Date().getFullYear();
        let pickerTarget = null;

        function renderPicker(year, month, targetDate) {
            pickerYear = year;
            pickerMonthGridEl.innerHTML = '';
            
            const yearSelect = document.createElement('select');
            yearSelect.id = 'picker-year-select';
            for (let y = 1901; y <= 2099; y++) {
                const option = new Option(y, y);
                if (y === year) option.selected = true;
                yearSelect.add(option);
            }

            const monthSelect = document.createElement('select');
            monthSelect.id = 'picker-month-select';
            for (let m = 0; m < 12; m++) {
                const option = new Option(`${m + 1}月`, m);
                if (m === month) option.selected = true;
                monthSelect.add(option);
            }

            const pickerNav = document.querySelector('#month-year-picker .year-nav');
            pickerNav.innerHTML = '';
            pickerNav.style.justifyContent = 'center';
            pickerNav.style.gap = '1rem';
            pickerNav.appendChild(yearSelect);
            pickerNav.appendChild(monthSelect);
            
            yearSelect.addEventListener('change', (e) => {
                if (pickerTarget) {
                    const newYear = parseInt(e.target.value, 10);
                    const currentMonth = parseInt(monthSelect.value, 10);
                    pickerTarget.currentDate = new Date(newYear, currentMonth, 1);
                    pickerTarget.render();
                    renderPicker(newYear, currentMonth, pickerTarget.currentDate);
                }
            });

            monthSelect.addEventListener('change', (e) => {
                if (pickerTarget) {
                    const newMonth = parseInt(e.target.value, 10);
                    const currentYear = parseInt(yearSelect.value, 10);
                    pickerTarget.currentDate = new Date(currentYear, newMonth, 1);
                    pickerTarget.render();
                    hideModal('modal-backdrop-picker');
                }
            });
        }

        function openPickerFor(targetWidget) { 
            if (isEditMode) return; 
            pickerTarget = targetWidget; 
            renderPicker(pickerTarget.currentDate.getFullYear(), pickerTarget.currentDate.getMonth(), pickerTarget.currentDate); 
            showModal('modal-backdrop-picker'); 
        }
            document.body.addEventListener('click',(e)=>{
                const selectHandle = e.target.closest('.group-select-handle');
                if (isEditMode && selectHandle) {
                    e.stopPropagation();
                    const widget = selectHandle.closest('.widget-container');
                    if (widget) toggleWidgetSelection(widget);
                    return;
                }
                const resetHandle = e.target.closest('.reset-handle');
                if (isEditMode && resetHandle) {
                    e.stopPropagation();
                    const widgetEl = resetHandle.closest('.widget-container');
                    if (widgetEl) {
                        const widgetId = widgetEl.id;
                        const defaultState = userDefaultLayout.transforms[widgetId];
                        if (transformStates[widgetId] && defaultState) {
                            const state = transformStates[widgetId];
                            const currentWidth = state.width * state.scale;
                            const currentHeight = state.height * state.scale;
                            const centerX = state.left + currentWidth / 2;
                            const centerY = state.top + currentHeight / 2;
                            state.width = defaultState.width;
                            state.height = defaultState.height;
                            state.scale = 1;
                            state.rotation = 0;
                            state.left = centerX - (state.width / 2);
                            state.top = centerY - (state.height / 2);
                            checkAndClampWidgetBounds(state);
                            applyTransform(widgetEl, state);
                            saveCurrentSettings();
                        }
                    }
                    return;
                }
                const cell=e.target.closest('.calendar-day');const key=e.target.dataset.key;if(key&&explanations[key]){e.stopPropagation();showExplanationModal(key,explanations[key]);return}if(cell&&cell.closest('#calendar-body')&&cell.dataset.date){showDayDetailModal(cell.dataset.date)}const closeModalBtn=e.target.closest('[data-close-modal]');if(closeModalBtn){hideModal(closeModalBtn.dataset.closeModal)}if(e.target.classList.contains('modal-backdrop')){hideModal(e.target.id)}});
            document.getElementById('marquee-params-btn').addEventListener('click', () => showModal('modal-backdrop-marquee-params'));
            document.addEventListener('keydown',(e)=>{if(e.key==='Escape'){['modal-backdrop-day','modal-backdrop-picker','modal-backdrop-explanation','modal-backdrop-settings','modal-backdrop-prompt', 'modal-backdrop-marquee-params'].forEach(hideModal)}});
            function resetActivityTimeout(){actionButtons.classList.remove('hidden');clearTimeout(activityTimeout);if(!isEditMode){activityTimeout=setTimeout(()=>actionButtons.classList.add('hidden'),3000)}}
            ['mousemove','mousedown','touchstart','keydown'].forEach(event=>document.addEventListener(event,resetActivityTimeout));
            document.getElementById('fullscreen-btn').addEventListener('click',()=>{if(!document.fullscreenElement){document.documentElement.requestFullscreen()}else{document.exitFullscreen()}});
            document.addEventListener('fullscreenchange',()=>{const isFullscreen=!!document.fullscreenElement;document.getElementById('fullscreen-enter-icon').classList.toggle('display-none',isFullscreen);document.getElementById('fullscreen-exit-icon').classList.toggle('display-none',!isFullscreen)});
            // ===================================================================
            // 應用程式初始化
            // ===================================================================
            function initializeWidgetControls() {
                const resetHandleHTML = `<div class="reset-handle control-handle" title="還原尺寸與旋轉"><svg class="width-full height-full" viewBox="0 0 24 24"><use href="#icon-reset-size"></use></svg></div>`;
                // 2025-09-25: 移除中央的移動圖示 HTML
                // const moveHandleHTML = `<div class="move-handle control-handle"><svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="width-full height-full"><use href="#icon-move"></use></svg></div>`;
                const resizeHandlesHTML = `<div class="resize-handle-w control-handle"></div><div class="resize-handle-h control-handle"></div>`;
                const groupSelectHTML = `<div class="group-select-handle" title="加入/移出群組"><svg class="unchecked" style="display: block;" viewBox="0 0 24 24"><use href="#icon-checkbox-unchecked" stroke="white"></use></svg><svg class="checked" style="display: none;" viewBox="0 0 24 24"><use href="#icon-checkbox-checked" stroke="white"></use></svg></div>`;
                const rotateHandleHTML = `<div class="rotate-handle control-handle" title="旋轉"><svg class="width-full height-full" viewBox="0 0 24 24"><use href="#icon-rotate"></use></svg></div>`;
                // 2025-09-25: 新增左下角的縮放圖示 HTML
                const scaleHandleHTML = `<div class="scale-handle control-handle" title="縮放"><svg class="width-full height-full" viewBox="0 0 24 24"><use href="#icon-scale"></use></svg></div>`;
                
                document.querySelectorAll('.widget-container').forEach(widgetEl => {
                    widgetEl.insertAdjacentHTML('afterbegin', groupSelectHTML);
                    widgetEl.insertAdjacentHTML('beforeend', resetHandleHTML);
                    // 2025-09-25: 移除添加中央移動圖示的動作
                    // widgetEl.insertAdjacentHTML('beforeend', moveHandleHTML);
                    widgetEl.insertAdjacentHTML('beforeend', rotateHandleHTML);
                    // 2025-09-25: 新增添加左下角縮放圖示的動作
                    widgetEl.insertAdjacentHTML('beforeend', scaleHandleHTML);
                    if (widgetEl.id !== 'analog-clock-container') {
                        widgetEl.insertAdjacentHTML('beforeend', resizeHandlesHTML);
                    }
                });
            }
            const Calendar = createCalendarWidget({
                bodyId: 'calendar-body', yearHeaderId: 'year-header', backgroundMonthId: 'background-month',
                prevBtnId: 'prev-month', nextBtnId: 'next-month', todayBtnId: 'back-to-today',
                onCellRender: calendarCellRenderer, onHeaderClick: openPickerFor,
                getSetting: () => settingsState.calendar
            });
            const MoonPhaseWidget = createCalendarWidget({
                bodyId: 'moon-calendar-body', yearHeaderId: 'moon-phase-year-header', backgroundMonthId: 'moon-background-month',
                prevBtnId: 'moon-phase-prev-month', nextBtnId: 'moon-phase-next-month', todayBtnId: 'moon-phase-today',
                onCellRender: moonPhaseCellRenderer, onHeaderClick: openPickerFor,
                getSetting: () => settingsState.moonPhase
            });
            MoonPhaseWidget.getMoonPhaseSVG = getMoonPhaseSVG;
            const MarqueeManager = {
                instances: [],
                _lastUpdateTime: { s: -1, m: -1, d: -1 },
                _cachedReplacements: {},
                _weatherDataChanged: false,

                init() {
                    this.syncInstances();
                    // 首次執行以填滿快取
                    this._updateCacheAndGetStatus();
                    setInterval(() => this.updateAllContent(), 1000);
                },

                _updateCacheAndGetStatus() {
                    const now = new Date();
                    const s = now.getSeconds(), m = now.getMinutes(), d = now.getDate();
                    const status = { s: false, m: false, d: false, w: this._weatherDataChanged };

                    // 依賴鍊：如果日期變了，分鐘和秒鐘也必定需要更新
                    if (d !== this._lastUpdateTime.d) status.d = true;
                    if (status.d || m !== this._lastUpdateTime.m) status.m = true;
                    if (status.m || s !== this._lastUpdateTime.s) status.s = true;

                    // 根據狀態更新對應的快取資料
                    if (status.s) {
                        this._cachedReplacements['%ss%'] = String(s).padStart(2, '0');
                        this._cachedReplacements['%s%'] = s;
                        this._lastUpdateTime.s = s;
                    }

                    if (status.m) {
                        const h = now.getHours(), h12 = h % 12 || 12, amPm = h >= 12 ? 'PM' : 'AM';
                        const shichen = ShichenHelper.getData(now);
                        Object.assign(this._cachedReplacements, {
                            '%mm%': String(m).padStart(2, '0'), '%m%': m,
                            '%HH%': String(h).padStart(2, '0'), '%H%': h,
                            '%hh%': String(h12).padStart(2, '0'), '%h%': h12,
                            '%AP%': amPm, '%ap%': amPm.toLowerCase(), '%ap_c%': TimeHelper.getPeriodText(h),
                            '%SHICHEN_GZ%': shichen.gz, '%SHICHEN_NAME%': shichen.name, '%SHICHEN_CHAR%': shichen.char
                        });
                        this._lastUpdateTime.m = m;
                    }

                    if (status.d) {
                        const year = now.getFullYear(), month = now.getMonth() + 1, dayOfWeek = now.getDay();
                        const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'], dayOfWeekChars = ['日', '一', '二', '三', '四', '五', '六'];
                        const lunar = getLunarDate(now);
                        const moonDetails = lunar ? (moonPhaseData[lunar.day] || { n: '未知', a: '' }) : { n: '', a: '' };
                        const moonName = moonDetails.a ? `${moonDetails.n}(${moonDetails.a})` : moonDetails.n;
                        const yearGZ = tiangan.charAt((lunar.year - 4) % 10) + dizhi.charAt((lunar.year - 4) % 12);
                        const yearSX = shengxiao.charAt((lunar.year - 4) % 12);
                        const constellationInfo = getConstellation(now);
                        Object.assign(this._cachedReplacements, {
                            '%YYYY%': year, '%ROC_YY%': year - 1911, '%YY%': String(year).slice(-2),
                            '%MM%': String(month).padStart(2, '0'), '%M%': month, '%DD%': String(d).padStart(2, '0'), '%D%': d,
                            '%WEEKDAY%': weekdays[dayOfWeek], '%W_NUM%': dayOfWeek, '%W_SHORT%': `週${dayOfWeekChars[dayOfWeek]}`, '%W_CHAR%': dayOfWeekChars[dayOfWeek],
                            '%L_GZ%': yearGZ, '%L_SX%': yearSX,
                            '%LM_C%': lunar ? lunar.toString.split(/月/)[0] + '月' : '', '%LD_C%': lunar ? lunar.dayString : '',
                            '%MOON_PHASE%': moonName,
                            '%MOON_ICON%': lunar ? MoonPhaseWidget.getMoonPhaseSVG(lunar.day, '1em', `marquee-manager`) : '',
                            '%MOON_DAY%': lunar ? lunar.day : '',
                            '%CONSTELLATION%': constellationInfo ? constellationInfo.sign : ''
                        });
                        this._lastUpdateTime.d = d;
                    }

                    if (status.w) {
                        let weatherReplacements = { '%WEATHER_LOC%': Weather.getChineseLocationName(settingsState.location), '%WEATHER_DESC%': '讀取中', '%TEMP%': '...', '%SUNRISE%': '...', '%SUNSET%': '...' };
                        if (Weather.data) {
                            const formatTime = (dateStr) => dateStr ? new Date(dateStr).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) : 'N/A';
                            weatherReplacements = {
                                '%WEATHER_LOC%': Weather.getChineseLocationName(settingsState.location),
                                '%WEATHER_DESC%': Weather.getWeatherDescription(Weather.data.current.weather_code),
                                '%TEMP%': Math.round(Weather.data.current.temperature_2m),
                                '%SUNRISE%': formatTime(Weather.data.daily.sunrise[0]),
                                '%SUNSET%': formatTime(Weather.data.daily.sunset[0]),
                            };
                        }
                        Object.assign(this._cachedReplacements, weatherReplacements);
                        this._weatherDataChanged = false; // 重設標記
                    }
                    return status;
                },

                updateAllContent() {
                    const status = this._updateCacheAndGetStatus();
                    if (status.s || status.m || status.d || status.w) {
                        this.instances.forEach(inst => inst.updateContent(status, this._cachedReplacements));
                    }
                },
                syncInstances() { this.instances.forEach(inst => { if (inst.animationStyleTag) inst.animationStyleTag.remove(); }); this.instances = []; document.querySelectorAll('.marquee-widget').forEach((el, i) => { this.instances.push(new MarqueeInstance(el.id, i)); }); },
                rebuildAllAnimations() { this.instances.forEach(inst => inst.rebuildAnimation()); },
                rebuildAnimationByIndex(index) { if (this.instances[index]) this.instances[index].rebuildAnimation(); },
                setPlayState(shouldPlay) { this.instances.forEach(inst => inst.setPlayState(shouldPlay)); }
            };
            (async function initializeApp() {
                const autoSavedLayout = localStorage.getItem('widgets_autosave');
                if (autoSavedLayout) {
                    applyLayout(JSON.parse(autoSavedLayout));
                } else {
                    applyLayout(JSON.parse(JSON.stringify(userDefaultLayout)));
                }
                
                if (!settingsState.location) {
                    settingsState.location = "taiwan";
                }

                const savedLayouts = localStorage.getItem('widgets_layouts_v2');
                if (savedLayouts) {
                    try { layouts = JSON.parse(savedLayouts); } catch (e) { console.error("無法從 localStorage 解析版面設定", e); layouts = []; }
                }

                initializeWidgetControls();
                Calendar.init();
                MoonPhaseWidget.init();
                LedClock.init();
                AnalogClock.init();
                Weather.init(); 
                MarqueeManager.init();
                
                updateLocationSelectors();
                
                await Weather.updateWeather();

                setupTimedEffectControls();
                resetActivityTimeout();
                updateLayoutSelector();
                
                saveCurrentSettings(); 
                
                window.addEventListener('resize', () => { ensureWidgetsInBounds(); MarqueeManager.rebuildAllAnimations(); saveCurrentSettings(); });
                document.fonts.ready.then(() => { ensureWidgetsInBounds(); MarqueeManager.rebuildAllAnimations(); });
            })();
        });

            const lunarInfo=[0x04bd8,0x04ae0,0x0a570,0x054d5,0x0d260,0x0d950,0x16554,0x056a0,0x09ad0,0x055d2,0x04ae0,0x0a5b6,0x0a4d0,0x0d250,0x1d255,0x0b540,0x0d6a0,0x0ada2,0x095b0,0x14977,0x04970,0x0a4b0,0x0b4b5,0x06a50,0x06d40,0x1ab54,0x02b60,0x09570,0x052f2,0x04970,0x06566,0x0d4a0,0x0ea50,0x06e95,0x05ad0,0x02b60,0x186e3,0x092e0,0x1c8d7,0x0c950,0x0d4a0,0x1d8a6,0x0b550,0x056a0,0x1a5b4,0x025d0,0x092d0,0x0d2b2,0x0a950,0x0b557,0x06ca0,0x0b550,0x15355,0x04da0,0x0a5d0,0x14573,0x052d0,0x0a9a8,0x0e950,0x06aa0,0x0aea6,0x0ab50,0x04b60,0x0aae4,0x0a570,0x05260,0x0f263,0x0d950,0x05b57,0x056a0,0x096d0,0x04dd5,0x04ad0,0x0a4d0,0x0d4d4,0x0d250,0x0d558,0x0b540,0x0b5a0,0x195a6,0x095b0,0x049b0,0x0a974,0x0a4b0,0x0b27a,0x06a50,0x06d40,0x0af46,0x0ab60,0x09570,0x04af5,0x04970,0x064b0,0x074a3,0x0ea50,0x06b58,0x055c0,0x0ab60,0x096d5,0x092e0,0x0c960,0x0d954,0x0d4a0,0x0da50,0x07552,0x056a0,0x0abb7,0x025d0,0x092d0,0x0cab5,0x0a950,0x0b4a0,0x0baa4,0x0ad50,0x055d9,0x04ba0,0x0a5b0,0x15176,0x052b0,0x0a930,0x07954,0x06aa0,0x0ad50,0x05b52,0x04b60,0x0a6e6,0x0a4e0,0x0d260,0x0ea65,0x0d530,0x05aa0,0x076a3,0x096d0,0x04bd7,0x04ad0,0x0a4d0,0x1d0b6,0x0d250,0x0d520,0x0dd45,0x0b5a0,0x056d0,0x055b2,0x049b0,0x0a577,0x0a4b0,0x0aa50,0x1b255,0x06d20,0x0ada0,0x04950,0x097b8,0x04950,0x0b4a0,0x0b6a6,0x06d40,0x0ab50,0x052f4,0x052f0,0x0a960,0x0e964,0x0d4a0,0x0da50,0x1d552,0x056a0,0x096d0,0x055b5,0x049b0,0x0a5b0,0x0a4b5,0x0a4b0,0x1b25a,0x06d20,0x0ada0,0x14950,0x095b0,0x04977,0x04970,0x0a4b0,0x0b4b5,0x06a50,0x06d40,0x1ab54,0x02b60,0x09570,0x052f2,0x04970,0x06566,0x0d4a0,0x0ea50,0x06e95,0x05ad0,0x02b60,0x186e3,0x092e0,0x1c8d7,0x0c950,0x0d4a0,0x1d8a6,0x0b550,0x056a0,0x1a5b4,0x025d0,0x092d0,0x0d2b2,0x0a950,0x0b557,0x06ca0,0x0b550,0x15355,0x04da0,0x0a5d0,0x14573,0x052d0,0x0a9a8,0x0e950,0x06aa0,0x0aea6,0x0ab50,0x04b60,0x0aae4,0x0a570,0x05260,0x0f263,0x0d950,0x05b57,0x056a0,0x096d0,0x04dd5];
            const nStr1="日一二三四五六七八九十";const nStr2="初十廿卅"; const tiangan = "甲乙丙丁戊己庚辛壬癸"; const dizhi = "子丑寅卯辰巳午未申酉戌亥"; const shengxiao = "鼠牛虎兔龍蛇馬羊猴雞狗豬";
            const moonPhaseData={1:{n:'朔月',a:'新月',d:'月球位於日地之間，黑暗面朝向地球，不可見。'},2:{n:'既朔月',d:'新月之後，可見極細彎月。'},3:{n:'蛾眉新月',d:'月牙兒逐漸變寬，形如秀眉。'},4:{n:'蛾眉月',d:''},5:{n:'蛾眉月',d:''},6:{n:'夕月',d:'日落後不久即可在西方天空看到。'},7:{n:'上弦月',d:'可見月球被照亮的一半，形如字母 "D"。'},8:{n:'上弦月',d:''},9:{n:'九夜月',d:''},10:{n:'宵月',d:'夜晚大部分時間都能看到月亮。'},11:{n:'漸盈凸月',d:'月相接近圓滿。'},12:{n:'漸盈凸月',d:''},13:{n:'漸盈凸月',d:''},14:{n:'小望月',d:'距離滿月僅一步之遙。'},15:{n:'望月',a:'滿月',d:'地球位於日月之間，可見完整的月盤。'},16:{n:'既望月',d:'滿月之後，月亮開始由盈轉虧。'},17:{n:'立待月',d:'月出稍晚，需站著等待。'},18:{n:'居待月',d:'月出更晚，可坐著等待。'},19:{n:'寢待月',d:'月亮升起時已近睡覺時間。'},20:{n:'更待月',d:'月亮在深夜一更後升起。'},21:{n:'漸虧凸月',d:'可見部分減少，但仍大於一半。'},22:{n:'下弦月',d:'再次看到一半，形如反向 "D"。'},23:{n:'下弦月',d:''},24:{n:'有明月',d:'天將亮時，仍可見月亮。'},25:{n:'蛾眉殘月',d:'月相變回鐮刀形。'},26:{n:'蛾眉殘月',d:''},27:{n:'殘月',d:'月牙兒更細。'},28:{n:'殘月',d:''},29:{n:'曉月',d:'僅在黎明前短暫可見。'},30:{n:'晦月',d:'月亮完全消失，為農曆月結束。'}};
            const explanations = {"春節":"農曆新年的第一天，是華人最盛大的傳統節日。","元宵節":"農曆正月十五，又稱上元節。","端午節":"農曆五月初五，為紀念愛國詩人屈原的節日。","七夕":"農曆七月初七，又稱情人節。","中元節":"農曆七月十五，祭祀祖先、普渡孤魂的日子。","中秋節":"農曆八月十五，是家人團圓的日子。","除夕":"農曆年的最後一天。家人會在這天團聚吃年夜飯。","元旦":"公曆新年的第一天。","情人節":"西方的傳統節日，情侶們會在這天互贈禮物。","和平紀念日":"紀念1947年2月28日發生的二二八事件。","婦女節":"為慶祝婦女在經濟、政治和社會等領域做出的重要貢獻而設立的節日。","植樹節":"為激發人們愛林、造林的熱情，促進國土綠化而設立的節日。","愚人節":"在每年4月1日，人們習慣以各種方式互相欺騙、捉弄及取笑。","兒童節":"為保障兒童的權利而設立的節日。","勞動節":"對勞動者表示尊重和慶祝的日子。","母親節":"感謝母親的節日，通常在每年五月的第二個星期日。","父親節":"感謝父親的節日，訂於每年的八月八日。","國際父親節":"許多國家感謝父親的節日，訂於每年六月的第三個星期日。","軍人節":"紀念軍人對國家的貢獻與犧牲。","教師節":"感謝老師教導的節日。","國慶日":"紀念武昌起義，中華民國的國定假日。","台灣光復節":"紀念台灣在1945年10月25日結束日本統治。","萬聖夜":"在每年的10月31日，小孩會裝扮成各種鬼怪討糖果。","國父誕辰":"紀念中華民國國父孫中山先生的生日。","感恩節":"北美地區感謝豐收的傳統節日，在美國為十一月的第四個星期四。","平安夜":"聖誕節前夕，即12月24日夜晚。","聖誕節":"紀念耶穌基督誕生的日子。","跨年夜":"指元旦前一晚，即12月31日夜晚。","天公生":"農曆正月初九，玉皇大帝的誕辰。","土地公生":"農曆二月初二，為土地公（福德正神）的誕辰。","媽祖誕辰":"農曆三月二十三，是海上守護神媽祖的生日。","重陽節":"農曆九月初九，有登高、賞菊、敬老的習俗。","下元節":"農曆十月十五，是為水官解厄之辰。","臘八節":"農曆十二月初八，傳統上會喝臘八粥。","送神日":"農曆十二月二十四，送眾神明回天庭述職的日子。","立春":"春季的開始。","雨水":"降雨開始，雨量漸增。","驚蟄":"春雷始鳴，驚醒蟄伏的昆蟲。","春分":"晝夜等長的日子。","清明":"天氣轉暖，掃墓祭祖的傳統節日。","穀雨":"雨水增多，有利於穀類作物的生長。","立夏":"夏季的開始。","小滿":"農作物子粒開始灌漿飽滿。","芒種":"麥類等有芒作物成熟，夏種開始。","夏至":"北半球白晝最長的一天。","小暑":"天氣開始炎熱。","大暑":"一年中最熱的時期。","立秋":"秋季的開始。","處暑":"炎熱的夏天即將過去。","白露":"天氣轉涼，清晨的露水日益加重。","秋分":"晝夜等長的日子。","寒露":"氣溫更低，露水有寒意。","霜降":"天氣漸冷，開始有霜。","立冬":"冬季的開始。","小雪":"開始下雪，但雪量不大。","大雪":"降雪量增大，地面可能會有積雪。","冬至":"北半球白晝最短的一天。","小寒":"氣候開始寒冷。","大寒":"一年中最寒冷的時期。"};
            const lunarHolidays={"1-1":"春節","1-9":"天公生","1-15":"元宵節","2-2":"土地公生","3-23":"媽祖誕辰","5-5":"端午節","7-7":"七夕","7-15":"中元節","8-15":"中秋節","9-9":"重陽節","10-15":"下元節","12-8":"臘八節","12-24":"送神日","12-30":"除夕"};
            const gregorianHolidays = {"1-1":"元旦","2-14":"情人節","2-28":"和平紀念日","3-8":"婦女節","3-12":"植樹節","4-1":"愚人節","4-4":"兒童節","5-1":"勞動節","8-8":"父親節","9-3":"軍人節","9-28":"教師節","10-10":"國慶日","10-25":"台灣光復節","10-31":"萬聖夜","11-12":"國父誕辰","12-24":"平安夜","12-25":"聖誕節","12-31":"跨年夜"};            const solarTermConstants=[["小寒",1,5.4055],["大寒",1,20.12],["立春",2,3.87],["雨水",2,18.73],["驚蟄",3,5.63],["春分",3,20.646],["清明",4,4.81],["穀雨",4,20.1],["立夏",5,5.52],["小滿",5,21.04],["芒種",6,5.678],["夏至",6,21.37],["小暑",7,7.108],["大暑",7,22.83],["立秋",8,7.5],["處暑",8,23.13],["白露",9,7.646],["秋分",9,23.042],["寒露",10,8.318],["霜降",10,23.438],["立冬",11,7.438],["小雪",11,22.36],["大雪",12,7.18],["冬至",12,21.94]];
            const floatingHolidays = {"5-2-0":"母親節","6-3-0":"國際父親節","11-4-4":"感恩節"};
            const taiwanLocations = { "台灣": { "english": "taiwan", "districts": { "台灣": "taiwan" } }, "基隆市": { "english": "keelung", "districts": { "基隆市": "keelung", "仁愛區": "renai", "信義區": "xinyi", "中正區": "zhongzheng", "中山區": "zhongshan", "安樂區": "anle", "暖暖區": "nuannuan", "七堵區": "qidu" } }, "臺北市": { "english": "taipei", "districts": { "臺北市": "taipei", "中正區": "zhongzheng", "大同區": "datong", "中山區": "zhongshan", "松山區": "songshan", "大安區": "da'an", "萬華區": "wanhua", "信義區": "xinyi", "士林區": "shilin", "北投區": "beitou", "內湖區": "neihu", "南港區": "nangang", "文山區": "wenshan" } }, "新北市": { "english": "new taipei", "districts": { "新北市": "new taipei", "板橋區": "banqiao", "三重區": "sanchong", "中和區": "zhonghe", "永和區": "yonghe", "新莊區": "xinzhuang", "新店區": "xindian", "土城區": "tucheng", "蘆洲區": "luzhou", "樹林區": "shulin", "汐止區": "xizhi", "鶯歌區": "yingge", "三峽區": "sanxia", "淡水區": "danshui", "瑞芳區": "ruifang", "五股區": "wugu", "泰山區": "taishan", "林口區": "linkou", "深坑區": "shengkeng", "石碇區": "shiding", "坪林區": "pinglin", "三芝區": "sanzhi", "石門區": "shimen", "八里區": "bali", "平溪區": "pingxi", "雙溪區": "shuangxi", "貢寮區": "gongliao", "金山區": "jinshan", "萬里區": "wanli", "烏來區": "wulai" } }, "桃園市": { "english": "taoyuan", "districts": { "桃園市": "taoyuan", "桃園區": "taoyuan", "中壢區": "zhongli", "平鎮區": "pingzhen", "八德區": "bade", "楊梅區": "yangmei", "蘆竹區": "luzhu", "大溪區": "daxi", "龍潭區": "longtan", "龜山區": "guishan", "大園區": "dayuan", "觀音區": "guanyin", "新屋區": "xinwu", "復興區": "fuxing" } }, "臺中市": { "english": "taichung", "districts": { "臺中市": "taichung", "中區": "central", "東區": "east", "南區": "south", "西區": "west", "北區": "north", "北屯區": "beitun", "西屯區": "xitun", "南屯區": "nantun", "太平區": "taiping", "大里區": "dali", "霧峰區": "wufeng", "烏日區": "wuri", "豐原區": "fengyuan", "后里區": "houli", "石岡區": "shigang", "東勢區": "dongshi", "和平區": "heping", "新社區": "xinshe", "潭子區": "tanzi", "大雅區": "daya", "神岡區": "shengang", "大肚區": "dadu", "沙鹿區": "shalu", "龍井區": "longjing", "梧棲區": "wuqi", "清水區": "qingshui", "大甲區": "dajia", "外埔區": "waipu", "大安區": "daan" } }, "臺南市": { "english": "tainan", "districts": { "臺南市": "tainan", "中西區": "west central", "東區": "east", "南區": "south", "北區": "north", "安平區": "anping", "安南區": "annan", "永康區": "yongkang", "歸仁區": "guiren", "新化區": "xinhua", "左鎮區": "zuozhen", "玉井區": "yujing", "楠西區": "nanxi", "南化區": "nanhua", "仁德區": "rende", "關廟區": "guanmiao", "龍崎區": "longqi", "官田區": "guantian", "麻豆區": "madou", "佳里區": "jiali", "西港區": "xigang", "七股區": "qigu", "將軍區": "jiangjun", "學甲區": "xuejia", "北門區": "beimen", "新營區": "xinying", "後壁區": "houbi", "白河區": "baihe", "東山區": "dongshan", "六甲區": "liujia", "下營區": "xiaying", "柳營區": "liuying", "鹽水區": "yanshui", "善化區": "shanhua", "大內區": "danei", "山上區": "shanshang", "新市區": "xingshi", "安定區": "anding" } }, "高雄市": { "english": "kaohsiung", "districts": { "高雄市": "kaohsiung", "楠梓區": "nanzi", "左營區": "zuoying", "鼓山區": "gushan", "三民區": "sanmin", "鹽埕區": "yancheng", "前金區": "qianjin", "新興區": "xinxing", "苓雅區": "lingya", "前鎮區": "qianzhen", "旗津區": "qijin", "小港區": "xiaogang", "鳳山區": "fengshan", "林園區": "linyuan", "大寮區": "daliao", "大樹區": "dashu", "大社區": "dashe", "仁武區": "renwu", "鳥松區": "niaosong", "岡山區": "gangshan", "橋頭區": "qiaotou", "燕巢區": "yanchao", "田寮區": "tianliao", "阿蓮區": "alian", "路竹區": "luzhu", "湖內區": "hunei", "茄萣區": "qieding", "永安區": "yong'an", "彌陀區": "mizuo", "梓官區": "ziguan", "旗山區": "qishan", "美濃區": "meinong", "六龜區": "liugui", "甲仙區": "jiaxian", "杉林區": "shanlin", "內門區": "neimen", "茂林區": "maolin", "桃源區": "taoyuan", "那瑪夏區": "namasia" } }, "新竹縣": { "english": "hsinchu county", "districts": { "新竹縣": "hsinchu county", "竹北市": "zhubei", "竹東鎮": "zhudong", "新埔鎮": "xinpu", "關西鎮": "guanxi", "湖口鄉": "hukou", "新豐鄉": "xinfeng", "芎林鄉": "qionglin", "橫山鄉": "hengshan", "北埔鄉": "beipu", "寶山鄉": "baoshan", "峨眉鄉": "emei", "尖石鄉": "jianshi", "五峰鄉": "wufeng" } }, "苗栗縣": { "english": "miaoli", "districts": { "苗栗縣": "miaoli", "苗栗市": "miaoli city", "頭份市": "toufen", "苑裡鎮": "yuanli", "通霄鎮": "tongxiao", "竹南鎮": "zhunan", "後龍鎮": "houlong", "卓蘭鎮": "zhuolan", "大湖鄉": "dahu", "公館鄉": "gongguan", "銅鑼鄉": "tongluo", "南庄鄉": "nanzhuang", "頭屋鄉": "touwu", "三灣鄉": "sanwan", "三義鄉": "sanyi", "西湖鄉": "xihu", "造橋鄉": "zaoqiao", "獅潭鄉": "shitan", "泰安鄉": "taian" } }, "彰化縣": { "english": "changhua", "districts": { "彰化縣": "changhua", "彰化市": "changhua city", "員林市": "yuanlin", "和美鎮": "hemei", "鹿港鎮": "lukang", "溪湖鎮": "xihu", "田中鎮": "tianzhong", "北斗鎮": "beidou", "二林鎮": "erlin", "線西鄉": "xianxi", "伸港鄉": "shengang", "福興鄉": "fuxing", "秀水鄉": "xiushui", "花壇鄉": "huatan", "芬園鄉": "fenyuan", "大村鄉": "dacun", "埔鹽鄉": "puyan", "埔心鄉": "puxin", "永靖鄉": "yongjing", "社頭鄉": "shetou", "二水鄉": "ershui", "田尾鄉": "tianwei", "埤頭鄉": "pitou", "芳苑鄉": "fangyuan", "大城鄉": "dacheng", "竹塘鄉": "zhutang", "溪州鄉": "xizhou" } }, "南投縣": { "english": "nantou", "districts": { "南投縣": "nantou", "南投市": "nantou city", "埔里鎮": "puli", "草屯鎮": "caotun", "竹山鎮": "zhushan", "集集鎮": "jiji", "名間鄉": "mingjian", "鹿谷鄉": "lugu", "中寮鄉": "zhongliao", "魚池鄉": "yuchi", "國姓鄉": "guoxing", "水里鄉": "shuili", "信義鄉": "xinyi", "仁愛鄉": "ren'ai" } }, "雲林縣": { "english": "yunlin", "districts": { "雲林縣": "yunlin", "斗六市": "douliu", "斗南鎮": "dounan", "虎尾鎮": "huwei", "西螺鎮": "xiluo", "土庫鎮": "tuku", "北港鎮": "beigang", "古坑鄉": "gukeng", "大埤鄉": "dapi", "莿桐鄉": "citong", "林內鄉": "linnei", "二崙鄉": "erlun", "崙背鄉": "lunbei", "麥寮鄉": "mailiao", "東勢鄉": "dongshi", "褒忠鄉": "baozhong", "臺西鄉": "taixi", "元長鄉": "yuanchang", "四湖鄉": "sihu", "口湖鄉": "kouhu", "水林鄉": "shuilin" } }, "嘉義縣": { "english": "chiayi county", "districts": { "嘉義縣": "chiayi county", "太保市": "taibao", "朴子市": "puzi", "布袋鎮": "budai", "大林鎮": "dalin", "民雄鄉": "minxiong", "溪口鄉": "xikou", "新港鄉": "xingang", "六腳鄉": "liujiao", "東石鄉": "dongshi", "義竹鄉": "yizu", "鹿草鄉": "lucao", "水上鄉": "shuishang", "中埔鄉": "zhongpu", "竹崎鄉": "zhuqi", "梅山鄉": "meishan", "番路鄉": "fanlu", "大埔鄉": "dapu", "阿里山鄉": "alishan" } }, "屏東縣": { "english": "pingtung", "districts": { "屏東縣": "pingtung", "屏東市": "pingtung city", "潮州鎮": "chaozhou", "東港鎮": "donggang", "恆春鎮": "hengchun", "萬丹鄉": "wandan", "長治鄉": "changzhi", "麟洛鄉": "linluo", "九如鄉": "jiuru", "里港鄉": "ligang", "鹽埔鄉": "yanpu", "高樹鄉": "gaoshu", "萬巒鄉": "wanluan", "內埔鄉": "neipu", "竹田鄉": "zhutian", "新埤鄉": "xinpi", "枋寮鄉": "fangliao", "新園鄉": "xinyuan", "崁頂鄉": "kanding", "林邊鄉": "linbian", "南州鄉": "nanzhou", "佳冬鄉": "jiadong", "琉球鄉": "liuqiu", "車城鄉": "checheng", "滿州鄉": "manzhou", "枋山鄉": "fangshan", "三地門鄉": "sandimen", "霧臺鄉": "wutai", "瑪家鄉": "majia", "泰武鄉": "taiwu", "來義鄉": "laiyi", "春日鄉": "chunri", "獅子鄉": "shizi", "牡丹鄉": "mudan" } }, "宜蘭縣": { "english": "yilan", "districts": { "宜蘭縣": "yilan", "宜蘭市": "yilan city", "羅東鎮": "luodong", "蘇澳鎮": "su'ao", "頭城鎮": "toucheng", "礁溪鄉": "jiaoxi", "壯圍鄉": "zhuangwei", "員山鄉": "yuanshan", "冬山鄉": "dongshan", "五結鄉": "wujie", "三星鄉": "sanxing", "大同鄉": "datong", "南澳鄉": "nan'ao" } }, "花蓮縣": { "english": "hualien", "districts": { "花蓮縣": "hualien", "花蓮市": "hualien city", "鳳林鎮": "fenglin", "玉里鎮": "yuli", "新城鄉": "xincheng", "吉安鄉": "ji'an", "壽豐鄉": "shoufeng", "光復鄉": "guangfu", "豐濱鄉": "fengbin", "瑞穗鄉": "ruisui", "富里鄉": "fuli", "秀林鄉": "xiulin", "萬榮鄉": "wanrong", "卓溪鄉": "zhuoxi" } }, "臺東縣": { "english": "taitung", "districts": { "臺東縣": "taitung", "臺東市": "taitung city", "成功鎮": "chenggong", "關山鎮": "guanshan", "卑南鄉": "beinan", "鹿野鄉": "luye", "池上鄉": "chishang", "東河鄉": "donghe", "長濱鄉": "changbin", "太麻里鄉": "taimali", "大武鄉": "dawu", "達仁鄉": "daren", "金峰鄉": "jinfeng", "海端鄉": "haiduan", "延平鄉": "yanping", "綠島鄉": "ludao", "蘭嶼鄉": "lanyu" } }, "澎湖縣": { "english": "penghu", "districts": { "澎湖縣": "penghu", "馬公市": "magong", "湖西鄉": "huxi", "白沙鄉": "baisha", "西嶼鄉": "xiyu", "望安鄉": "wang'an", "七美鄉": "qimei" } }, "金門縣": { "english": "kinmen", "districts": { "金門縣": "kinmen", "金城鎮": "jincheng", "金湖鎮": "jinhu", "金沙鎮": "jinsha", "金寧鄉": "jinning", "烈嶼鄉": "lieyu", "烏坵鄉": "wuqiu" } }, "連江縣": { "english": "lienchiang", "districts": { "連江縣": "lienchiang", "南竿鄉": "nangan", "北竿鄉": "beigan", "莒光鄉": "juguang", "東引鄉": "dongyin" } }, "新竹市": { "english": "hsinchu", "districts": { "新竹市": "hsinchu", "東區": "east", "北區": "north", "香山區": "xiangshan" } }, "嘉義市": { "english": "chiayi", "districts": { "嘉義市": "chiayi", "東區": "east", "西區": "west" } } };
            const signs = [
                { sign: "摩羯座", m: 1, d: 20, range: "12/22 - 1/19" }, { sign: "水瓶座", m: 2, d: 19, range: "1/20 - 2/18" },
                { sign: "雙魚座", m: 3, d: 21, range: "2/19 - 3/20" }, { sign: "牡羊座", m: 4, d: 20, range: "3/21 - 4/19" },
                { sign: "金牛座", m: 5, d: 21, range: "4/20 - 5/20" }, { sign: "雙子座", m: 6, d: 22, range: "5/21 - 6/21" },
                { sign: "巨蟹座", m: 7, d: 23, range: "6/22 - 7/22" }, { sign: "獅子座", m: 8, d: 23, range: "7/23 - 8/22" },
                { sign: "處女座", m: 9, d: 23, range: "8/23 - 9/22" }, { sign: "天秤座", m: 10, d: 24, range: "9/23 - 10/23" },
                { sign: "天蠍座", m: 11, d: 23, range: "10/24 - 11/22" }, { sign: "射手座", m: 12, d: 22, range: "11/23 - 12/21" },
                { sign: "摩羯座", m: 13, d: 32, range: "12/22 - 1/19" } // 處理跨年
            ];
    </script>
</body>
</html>
